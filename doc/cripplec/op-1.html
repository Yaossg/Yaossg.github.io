<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Yaossg" /><link rel="canonical" href="https://yaossg.com/doc/cripplec/op-1.html" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>运算符（上） - Yaossg's Doc</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u8fd0\u7b97\u7b26\uff08\u4e0a\uff09";
        var mkdocs_page_input_path = "cripplec/op-1.md";
        var mkdocs_page_url = "/doc/cripplec/op-1.html";
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../index.html" class="icon icon-home"> Yaossg's Doc
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../index.html">Yaossg's Doc</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Cripple C</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="index.html">Cripple C</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="concept.html">基本概念</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="token.html">符号</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="text.html">文本</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="preprocessor.html">预处理器</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="op-1.html">运算符（上）</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#_2">运算符</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_3">优先级与结合性</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_4">前缀和后缀运算符</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_5">比较运算符</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_6">赋值运算符</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_7">= 与 ==</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_8">复合赋值运算符</a>
    </li>
        </ul>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="op-2.html">运算符（下）</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="int.html">整数</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="conv.html">隐式转换</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="cdecl.html">cdecl</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Yaossg's Doc</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html" class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>Cripple C &raquo;</li>
      <li>运算符（上）</li>
    <li class="wy-breadcrumbs-aside">
        <a href="https://github.com/Yaossg/doc/edit/master/docs/cripplec/op-1.md"
          class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="_1">运算符（上）</h1>
<h2 id="_2">运算符</h2>
<p>C 语言有非常多的运算符（operator），有些可能你都没意识到属于运算符：</p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>描述</th>
<th>结合性</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>++</code> <code>--</code></td>
<td>后缀自增与自减</td>
<td>从左到右</td>
</tr>
<tr>
<td>1</td>
<td><code>()</code> <code>[]</code></td>
<td>函数调用、数组下标</td>
<td>从左到右</td>
</tr>
<tr>
<td>1</td>
<td><code>.</code>  <code>-&gt;</code></td>
<td>成员访问</td>
<td>从左到右</td>
</tr>
<tr>
<td>1</td>
<td><code>(type){list}</code></td>
<td>复合字面量(C99)</td>
<td>从左到右</td>
</tr>
<tr>
<td>2</td>
<td><code>++</code> <code>--</code></td>
<td>前缀自增与自减</td>
<td>从右到左</td>
</tr>
<tr>
<td>2</td>
<td><code>+</code> <code>-</code> <code>!</code> <code>~</code></td>
<td>正负号、逻辑非、逐位非</td>
<td>从右到左</td>
</tr>
<tr>
<td>2</td>
<td><code>(type)</code></td>
<td>强制类型转换</td>
<td>从右到左</td>
</tr>
<tr>
<td>2</td>
<td><code>*</code>   <code>&amp;</code></td>
<td>解引用、取地址</td>
<td>从右到左</td>
</tr>
<tr>
<td>2</td>
<td><code>sizeof</code> <code>_Alignof</code></td>
<td>取大小、对齐要求(C11)</td>
<td>从右到左</td>
</tr>
<tr>
<td>3</td>
<td><code>*</code> <code>/</code> <code>%</code></td>
<td>乘法、除法、余数</td>
<td>从左到右</td>
</tr>
<tr>
<td>4</td>
<td><code>+</code> <code>-</code></td>
<td>加法、减法</td>
<td>从左到右</td>
</tr>
<tr>
<td>5</td>
<td><code>&lt;&lt;</code> <code>&gt;&gt;</code></td>
<td>左移、右移</td>
<td>从左到右</td>
</tr>
<tr>
<td>6</td>
<td><code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code></td>
<td>小于、小于等于、大于、大于等于</td>
<td>从左到右</td>
</tr>
<tr>
<td>7</td>
<td><code>==</code> <code>!=</code></td>
<td>等于、不等于</td>
<td>从左到右</td>
</tr>
<tr>
<td>8</td>
<td><code>&amp;</code></td>
<td>按位与</td>
<td>从左到右</td>
</tr>
<tr>
<td>9</td>
<td><code>^</code></td>
<td>按位异或</td>
<td>从左到右</td>
</tr>
<tr>
<td>10</td>
<td><code>|</code></td>
<td>按位或</td>
<td>从左到右</td>
</tr>
<tr>
<td>11</td>
<td><code>&amp;&amp;</code></td>
<td>逻辑与</td>
<td>从左到右</td>
</tr>
<tr>
<td>12</td>
<td><code>||</code></td>
<td>逻辑或</td>
<td>从左到右</td>
</tr>
<tr>
<td>13</td>
<td><code>?:</code></td>
<td>条件</td>
<td>从右到左</td>
</tr>
<tr>
<td>14</td>
<td><code>=</code></td>
<td>简单赋值</td>
<td>从右到左</td>
</tr>
<tr>
<td>14</td>
<td><code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code></td>
<td>算术运算复合赋值</td>
<td>从右到左</td>
</tr>
<tr>
<td>14</td>
<td><code>&lt;&lt;=</code> <code>&gt;&gt;=</code> <code>&amp;=</code> <code>^=</code> <code>|=</code></td>
<td>位运算复合赋值</td>
<td>从右到左</td>
</tr>
<tr>
<td>15</td>
<td><code>,</code></td>
<td>逗号</td>
<td>从左到右</td>
</tr>
</tbody>
</table>
<h2 id="_3">优先级与结合性</h2>
<p>运算符优先级和结合性是最常见的容易犯错的地方。在解析一个表达式的时候，优先级是首先应该考虑的因素。在优先级相同的情况下，我们再讨论结合性。</p>
<p>运算符的优先级大致可以这样记忆：后缀&gt;前缀&gt;乘除余&gt;加减&gt;位移&gt;比较&gt;位运算&gt;条件&gt;赋值&gt;逗号。</p>
<p>至于结合性，是很容易误解的一个概念。我们日常生活中进行的运算都是左结合的，也就是从左到右计算。例如<code>1 + 2 - 3</code>的含义是<code>(1 + 2) - 3</code>而不是<code>1 + (2 - 3)</code>。C 语言也在这方面保持了一致。问题出在我们日常生活中没遇到的运算符，以及平时没当作运算符的运算符。</p>
<p>对于前缀、后缀运算符，因为其性质决定，所以必然只能右结合、左结合。毕竟<code>a[1][1]</code>解读为<code>a([1][1])</code>，<code>**a</code>解读为<code>(**)a</code>也完全没有意义嘛。不过多个连续的符号，是有可能解读为一个符号的，例如<code>++a</code>显然不会是<code>+(+a)</code>，但这就不是结合性的问题，而是<a href="token.html">符号</a>的问题了。</p>
<p>结合性最典型的示例就是赋值运算符，因为它的语义就是从右往左赋值，因此自然也是从右往左计算的。<code>a = b = c</code>的含义是<code>a = (b = c)</code>而不会是<code>(a = b) = c</code>，就是这个道理。</p>
<p>下面分别详细讲一下这些运算符。</p>
<h2 id="_4">前缀和后缀运算符</h2>
<p>首先应该注意到后缀运算符至高无上的地位，他比前缀运算符还要高。所以<code>*p.a</code>、<code>*p(a)</code>、<code>*p[a]</code>、<code>*p++</code>实际上都是<code>*(p.a)</code>、<code>*(p(a))</code>、<code>*(p[a])</code>、<code>*(p++)</code>。在进行指针方面的操作的时候尤其需要注意到这一点。</p>
<p>不过考虑到经常使用，C 语言还提供了更简单的方法：对于指向结构的指针<code>p</code>来说<code>(*p).a</code>可以写作<code>p-&gt;a</code>，而对于指向函数的指针<code>p</code>来说<code>(*p)(a)</code>则可以直接写作<code>p(a)</code>。</p>
<p>数组下标运算<code>a[n]</code>实际上等价于<code>(*(a+(n)))</code>。根据加法交换律，你实际上可以可以写成<code>n[a]</code>。然而与此同时，请注意细品这三个括号的意蕴。例如，如果你把<code>p[-1]</code>转写成<code>-1[p]</code>，那么它的含义就悄悄地变成了<code>-(1[p])</code>，这是完全不同的含义。</p>
<p><code>sizeof</code>和类型转换也是运算符，你意识到了吗？如果右侧是表达式，<code>sizeof</code>是可以不加括号的，例如：</p>
<pre><code class="language-C">size_t sz = sizeof 0; // sz == sizeof(int)
</code></pre>
<p>但是如果是类型，就必须加括号，如<code>sizeof(int)</code>。目前一切安好，但是你考虑过下面这样的表达式吗：</p>
<pre><code class="language-C">sizeof (int) * p
</code></pre>
<p>它实际上的含义是<code>(sizeof(int)) * p</code>而不是<code>sizeof((int) *p)</code>者。你可能觉得这里违背了结合性原则，但是我需要提醒你的是，<code>sizeof(int)</code>的<code>sizeof</code>根本不是参与表达式解析的运算符了。不过这不影响 C99 的复合字面量，下面的表达式</p>
<pre><code class="language-C">sizeof (int){0}
</code></pre>
<p>的含义仍然是</p>
<pre><code class="language-C">sizeof((int){0})
</code></pre>
<p>综上所示，无论<code>sizeof</code>后面跟的是什么，括号总能帮助我们很好的消除歧义。</p>
<p><code>++</code>和<code>--</code>运算符既有前缀形式，又有后缀形式，优先级上，始终秉持先后缀再前缀的原则。例如<code>++*p++</code>便是<code>++(*(p++))</code>的意思。</p>
<p>需要注意的是，如果你打了奇数个加号，是不能通过编译的。根据贪心法，<code>+++i</code>会被解读为<code>++(+i)</code>，而<code>+i</code>是右值不是左值（这可能算得上是单目加号为数不多的作用之一）。这可能与你的直觉相悖，不是说单目运算符是右结合的吗？还是那句话，这已经不是结合性的问题，而是<a href="token,md">符号</a>中讨论的问题了。</p>
<p>在 C 语言中，即时没有参数，调用函数也一定需要一个括号：</p>
<pre><code class="language-C">f(); // 调用无参函数 f
f; // 什么也不做
</code></pre>
<p>不带括号的函数名字，还可以取，或退化成它自己的地址，成为函数指针。参见<a href="conv.html#退化">这里</a>。</p>
<h2 id="_5">比较运算符</h2>
<p>C 语言的比较运算符是比较朴素的，表达式</p>
<pre><code class="language-C">a &lt; b &lt; c
</code></pre>
<p>的实际含义是</p>
<pre><code class="language-C">(a &lt; b) &lt; c
</code></pre>
<p>也就是说，把<code>a &lt; b</code>的结果，与<code>c</code>作比较。如果真实的意图是想要判断它们是否严格升序，正确的写法应该是</p>
<pre><code class="language-C">a &lt; b &amp;&amp; b &lt; c
</code></pre>
<p>而下面这段代码</p>
<pre><code class="language-C">a &lt; b == c &lt; d
</code></pre>
<p>的含义可能更为出乎意料。虽然都是比较运算符，但是他们的优先级并不都是一样的！所以这个表达式的等价于</p>
<pre><code class="language-C">(a &lt; b) == (c &lt; d)
</code></pre>
<p>它表示的意思是要么<code>a &lt; b</code>和<code>c &lt; d</code>同时成立，要么同时不成立的时候，表达式为真，即”逻辑同或“，类似的，可以用<code>!=</code>来作为逻辑异或运算符。不过在这样使用的时候，还是尽可能打上括号，便于理解。</p>
<h2 id="_6">赋值运算符</h2>
<h3 id="_7"><code>=</code> 与 <code>==</code></h3>
<p>对于初学者来说容易犯的一个错误就是混淆比较与赋值运算符。在 C 语言里，<code>=</code>是赋值运算符，<code>==</code>才是比较操作数是否相等。例如下面的代码，实际上是把<code>5</code>赋值给<code>x</code>，接着判断<code>x</code>是否非零。</p>
<pre><code class="language-C">if (x = 5)
    printf(&quot;x = 5&quot;);
</code></pre>
<p>再看下面的一个例子，它的本意是跳过文件中的空格、制表符和换行符。</p>
<pre><code class="language-C">while (c = ' ' || c == '\t' || c == '\n')
    c = getc(f);
</code></pre>
<p>它实际上是吧<code>' ' || c == '\t' || c == '\n'</code>的值赋值给<code>c</code>，接着判断<code>c</code>是否非零，而这一定是真的！</p>
<p>解决上面这个问题的一种方法是把常量放置在左侧：</p>
<pre><code class="language-C">if (5 = x) // ERROR!
    printf(&quot;x = 5&quot;);
</code></pre>
<p>如果你真的想要在条件语句赋值，你可以写成下面这样：</p>
<pre><code class="language-C">while ((ch = *p++) != 0)
    ...
</code></pre>
<p>实际上，对于任何整数作为条件，<code>!= 0</code>都能作为最好的注解。</p>
<p>但是要注意，这里的括号是重中之重。这是因为，赋值运算符的优先级比不等于号低。如果不加，写成</p>
<pre><code class="language-C">while (ch = *p++ != 0)
    ...
</code></pre>
<p>就会被解读为</p>
<pre><code class="language-C">while (ch = (*p++ != 0))
    ...
</code></pre>
<p>在这里，你或许可以省略为</p>
<pre><code class="language-C">while (ch = *p++)
    ...
</code></pre>
<p>但是在进行文件操作的时候，你可能会遇到与<code>EOF</code>的比较，就不能作此简写，这个时候你就不得不小心了。</p>
<p>此外，在 C++ 中还有另一种更为人接受的方式：</p>
<pre><code class="language-C++">while (char ch = *p++)
    ...
</code></pre>
<p>这很明显是赋值（更准确的说，初始化）而不是比较了。注意，别忘了它声明的变量及其作用域。</p>
<hr />
<p>反过来说，如果你把<code>=</code>不慎写成了<code>==</code>，一般也不会引发编译错误，但你的语句便不会产生任何效果。</p>
<h3 id="_8">复合赋值运算符</h3>
<p>无论原运算符是什么优先级，复合赋值运算符都是同一等级的，且为右结合。例如</p>
<pre><code class="language-C">a *= b += c;
</code></pre>
<p>应该是</p>
<pre><code class="language-C">a *= (b += c);
</code></pre>
<p>而不是</p>
<pre><code class="language-C">(a *= b) += c;
</code></pre>
<p>此外，因为较低的优先级，可以认为，复合赋值运算符自带了一个“括号的语义”，例如</p>
<pre><code class="language-C">a *= b + c;
</code></pre>
<p>不能直接转写为</p>
<pre><code class="language-C">a = a * b + c;
</code></pre>
<p>而是应该写作</p>
<pre><code class="language-C">a = a * (b + c);
</code></pre>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="preprocessor.html" class="btn btn-neutral float-left" title="预处理器"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="op-2.html" class="btn btn-neutral float-right" title="运算符（下）">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/Yaossg/doc" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="preprocessor.html" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="op-2.html" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
