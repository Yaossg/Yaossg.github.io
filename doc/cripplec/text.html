<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Yaossg" /><link rel="canonical" href="https://yaossg.com/doc/cripplec/text.html" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>文本 - Yaossg's Doc</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u6587\u672c";
        var mkdocs_page_input_path = "cripplec/text.md";
        var mkdocs_page_url = "/doc/cripplec/text.html";
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../index.html" class="icon icon-home"> Yaossg's Doc
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../index.html">Yaossg's Doc</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Cripple C</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="index.html">Cripple C</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="concept.html">基本概念</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="token.html">符号</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="text.html">文本</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#_2">字符串</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_3">转义序列</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_4">数字转义序列</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_5">字符集与编码</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_6">通用字符名</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_7">双字符与三字符</a>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="preprocessor.html">预处理器</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="op-1.html">运算符（上）</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="op-2.html">运算符（下）</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="int.html">整数</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="conv.html">隐式转换</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="cdecl.html">cdecl</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">字符集与编码</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../ce/overview.html">概述</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Yaossg's Doc</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html" class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>Cripple C &raquo;</li>
      <li>文本</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/Yaossg/doc/edit/master/docs/cripplec/text.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="_1">文本</h1>
<blockquote>
<p><em>Oh what a tangled web we weave, when we first practice to deceive</em> ——Walter Scott</p>
<p>⚠️ 你先别急 ⚠️ 🚧 本页面仍在施工中 🚧</p>
</blockquote>
<h2 id="_2">字符串</h2>
<p>与一些语言（例如 Python）不同，C 语言是区分字符（character）和字符串（string）的。用单引号括起来的是字符，双引号括起来的是字符串。因此这两个符号也是不可以混淆的。一些编译器可能会允许单引号内包含多个字符（并一般会同时给出警告），但是一定要切记不能依赖于这样的扩展特性。</p>
<p>字符串的末尾是有一个隐式的<code>'\0'</code>作为结尾的，因此即使是空字符串也是有一个字符在里面的。在进行初始化的时候，如果空间没给够，最后一个<code>'\0'</code>会被省略。（C++ 禁止这样的初始化）</p>
<pre><code class="language-C">char hi0[] = &quot;hi&quot;; // sizeof(hi0) == sizeof(&quot;hi&quot;) == 3
char hi1[3] = &quot;hi&quot;; // char hi1[3] = {'h', 'i', '\0'};
char hi2[2] = &quot;hi&quot;; // char hi2[2] = {'h', 'i'}; and Error in C++
</code></pre>
<p>更加广为人诟病的是，明明作为一个实际上不应该可变的字符数组，字符串常量却在 C 语言中拥有非<code>const</code>的类型，进而也可以赋值给非<code>const</code>的字符指针。</p>
<pre><code class="language-C">char* s = &quot;string-literal&quot;; // OK in C, Error since C++11
s[0] = 'r'; // UB
</code></pre>
<p>如果一个字符串常量非常长，想要写到多行里面，怎么办？一种古老的方法是在行末加反斜杠<code>\</code>来抵消换行符，如</p>
<pre><code class="language-C">const char* greetings = &quot;hello\
 world&quot;;
</code></pre>
<p>这个特性实际上更广泛的用于多行的宏定义里面：</p>
<pre><code class="language-C">#define LOG(fp, msg)  \
    printf(&quot;%s&quot;, msg); \
    fprintf(fp, &quot;%s&quot;, msg)
</code></pre>
<p>但是要注意，这样的抵消在注释里仍然奏效，可能会带来意料之外的后果：</p>
<pre><code class="language-C">// 下一行代码总是不会被执行 \
...
</code></pre>
<p>因为第一行行末换行符被抵消了，这会导致下一行代码也被注释掉。</p>
<p>不过对于字符串常量来说，还有一个特殊的特性，那就是相邻的两个字符串常量自动连接：</p>
<pre><code class="language-C">const char* greetings1 = &quot;hello&quot;
    &quot; world&quot;;
const char* greetings2 = &quot;hello&quot; &quot; world&quot;;
const char* greetings3 = &quot;hello&quot;&quot; world&quot;;
</code></pre>
<p>这三个与上面的<code>greetings</code>都是等价的。</p>
<p>这个语法还可以用来避免一些尴尬的情况：</p>
<pre><code class="language-C">const char* p = &quot;\x41F&quot;; // Error: 0x41F 太大了
const char* q = &quot;\x41&quot;&quot;F&quot;; // OK: 包含 'A' 'F' 和 '\0' 三个字符
</code></pre>
<p>当然这样的连接有可能会发生在你意想不到的地方：</p>
<pre><code class="language-C">const char* messages[] = {
    &quot;find&quot;,
    &quot;trouble&quot; // 哎呀！忘了一个逗号
    &quot;maker&quot;,  // OK，末尾多余的逗号是被允许的
};
</code></pre>
<p>可以发现，最后两个字符串意外的被连起来了，我们很可能并不是想要一个<code>"troublemaker"</code>，而是两个字符串常量。</p>
<p>此外，字符串常量是可以有前缀的，<code>"..."</code>的类型是<code>char[N]</code>，而<code>L"..."</code>的类型则是<code>wchar_t[N]</code>。在连接的时候，如果其中一个字符串常量是有前缀的，那么就会使用这种前缀：</p>
<pre><code class="language-C">const wchar_t* p = L&quot;123&quot; &quot;123&quot;; // L&quot;123123&quot;
const wchar_t* q = &quot;123&quot; L&quot;123&quot;; // 同上
const wchar_t* r = L&quot;123&quot; L&quot;123&quot;; // 同上
</code></pre>
<p>第一种和第三种情况比较容易理解，第二种写法可能会引起误会，但也可以接受。无法接受的是混合前缀：</p>
<pre><code class="language-C">u&quot;123&quot; U&quot;123&quot; // 注意大小写
</code></pre>
<p><code>u"..."</code>的类型是<code>char16_t[N]</code>，而<code>U"..."</code>的类型则是<code>char32_t[N]</code>。这下你给编译器整不会了，听谁的好呢？随着标准收紧这种奇怪的写法不再被允许，但即使在被允许的时候，也几乎没有任何编译器给出一个合理的实现！</p>
<p>这些不同宽度的字符类型，自然是为了不同编码的字符而来。C 的宏（C++ 的关键字）<code>wchar_t</code>，是平台相关的宽字符，在 Windows 下是两字节（默认为 GBK 或其他本地字符集），而在 *nix 下是四字节（Unicode）。而 C 的宏（C++ 的关键字）<code>char8_t</code>、<code>char16_t</code>、<code>char32_t</code>，虽说是编译器决定，但出于其极强的暗示性，往往都被实现为 UTF-8 UTF-16 和 UTF-32。</p>
<hr />
<p>但是无论是初始化时字符串常量赋值给数组，还是相邻的字符串常量连接在一起，这都是编译器在耍花招而已——那只是编译时字面量的操作而已。当你真的需要给字符数组赋值或者连接两个字符数组时，你还是需要调用库函数<code>strcpy</code>和<code>strcat</code>来实现。</p>
<h2 id="_3">转义序列</h2>
<p>转义序列（escape sequence）指的是利用反斜杠<code>\</code>及其后面的若干个字符来表示一些特殊的字符的方式。</p>
<table>
<thead>
<tr>
<th>转义序列</th>
<th>含义</th>
<th>ASCII</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\'</code></td>
<td>单引号</td>
<td><code>0x27</code></td>
</tr>
<tr>
<td><code>\"</code></td>
<td>双引号</td>
<td><code>0x22</code></td>
</tr>
<tr>
<td><code>\?</code></td>
<td>问号</td>
<td><code>0x3f</code></td>
</tr>
<tr>
<td><code>\\</code></td>
<td>反斜杠</td>
<td><code>0x5c</code></td>
</tr>
<tr>
<td><code>\a</code></td>
<td>响铃</td>
<td><code>0x07</code></td>
</tr>
<tr>
<td><code>\b</code></td>
<td>退格</td>
<td><code>0x08</code></td>
</tr>
<tr>
<td><code>\f</code></td>
<td>换页</td>
<td><code>0x0c</code></td>
</tr>
<tr>
<td><code>\n</code></td>
<td>换行</td>
<td><code>0x0a</code></td>
</tr>
<tr>
<td><code>\r</code></td>
<td>回车</td>
<td><code>0x0d</code></td>
</tr>
<tr>
<td><code>\t</code></td>
<td>水平制表</td>
<td><code>0x09</code></td>
</tr>
<tr>
<td><code>\v</code></td>
<td>垂直制表</td>
<td><code>0x0b</code></td>
</tr>
<tr>
<td><code>\</code><em>ooo</em></td>
<td>三位八进制的值</td>
<td></td>
</tr>
<tr>
<td><code>\x</code><em>hh...</em></td>
<td>十六进制的值</td>
<td></td>
</tr>
<tr>
<td><code>\u</code><em>hhhh</em> (C99）</td>
<td>四位十六进制的 Unicode 值</td>
<td></td>
</tr>
<tr>
<td><code>\U</code><em>hhhhhhhh</em> (C99)</td>
<td>八位十六进制的 Unicode 值</td>
<td></td>
</tr>
</tbody>
</table>
<p>问号为什么需要转义？你先别急！后文将会揭晓。</p>
<h3 id="_4">数字转义序列</h3>
<p>开始前先个问你一个问题：<code>'\42'</code>是多少？</p>
<p>答案是<code>34</code>。八进制总是令人着迷。你还会<a href="int.html">再见到它</a>的。</p>
<hr />
<p>八进制转义序列最多接受三位八进制数，且会在第一个非八进制数字处停止。十六进制转义序列没有这个限制，接受任意位十六进制数，但也会在第一个非十六进制数字处停止（你也可以将其理解为一种贪心法）。如果转义序列的值超出了它字符类型的范围，结果是未定义的。</p>
<p>Unicode 的转义序列要求的长度是固定的。短了非法，长了直接不算作转义序列的一部分。由于 Unicode 编码的取值范围是0~0xD800，0xE000~0x10FFFF（中间为什么缺了一段？为什么最大值是这么奇怪的一个数字？请参见 UTF-16 的设计方案），所以八位十六进制的 Unicode 转义序列注定至少有前两位是 0（我也很难理解他们为什么要这么设计……可能是为了说明字符确实是 32 位？抑或是为日后的扩展做准备？）。</p>
<p>Unicode 转义序列还有一个不同之处在于，它表示的永远是一个实实在在的 Unicode 字符，而不是表示任何一种编码。它会根据字符串的编码进行具体的转译，例如对于字符 🍌（U+1f34c）来说：</p>
<pre><code class="language-C">char ch0     =  '🍌'; // ill-formed
char16_t ch1 = u'🍌'; // ill-formed
char32_t ch2 = U'🍌'; // OK
char s0[]     =  &quot;\U0001f34c&quot;; // 0xf0, 0x9f, 0x8d, 0x8c
char16_t s1[] = u&quot;\U0001f34c&quot;; // 0xd83c, 0xdf4c
char32_t s2[] = U&quot;\U0001f34c&quot;; // 0x0001f34c
// 注：上面的代码里的 🍌 和 \U0001f34c 是可以互换的，效果一样

char16_t err[] = u&quot;\ud83c\udf4c&quot;; // ERROR: U+d83c 和 U+df4c 不是 Unicode 字符
</code></pre>
<p>可以看到，最后一行的表示，看上去似乎跟第五行的表示是一样的，那就犯了想当然的错误。Unicode 转义序列一定是表示一个完整的字符，而不能是其中的某一部分。一个字符到底如何编码、占多少字节，并不是由这个转义序列本身决定的。</p>
<h2 id="_5">字符集与编码</h2>
<p>字符集（character set）就是一系列字符组成的集合。而这些字符与整数的对应关系，被称为编码（encoding）。</p>
<p>你的键盘能直接打出来的字毕竟是少数。借助输入法的确可以补充不少，但依然杯水车薪。</p>
<p>上面的转义序列或许展示了一种方法在字符串里进行字符代替。但是源代码有时同样需要转义！</p>
<blockquote>
<p>🚧 施工中 🚧</p>
</blockquote>
<p>一种替换的方案在<a href="op-2.html#iso646">这里</a>介绍。</p>
<h2 id="_6">通用字符名</h2>
<blockquote>
<p>🚧 施工中 🚧</p>
</blockquote>
<h2 id="_7">双字符与三字符</h2>
<p>双字符（digraph）和三字符（trigraph）可以用来代替一些缺少特殊字符的键盘不能打出来的基本字符。</p>
<table>
<thead>
<tr>
<th>原字符</th>
<th>双字符</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>{</code></td>
<td><code>&lt;%</code></td>
</tr>
<tr>
<td><code>}</code></td>
<td><code>%&gt;</code></td>
</tr>
<tr>
<td><code>[</code></td>
<td><code>&lt;:</code></td>
</tr>
<tr>
<td><code>]</code></td>
<td><code>:&gt;</code></td>
</tr>
<tr>
<td><code>#</code></td>
<td><code>%:</code></td>
</tr>
<tr>
<td><code>##</code></td>
<td><code>%:%:</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>原字符</th>
<th>三字符</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>{</code></td>
<td><code>??&lt;</code></td>
</tr>
<tr>
<td><code>}</code></td>
<td><code>??&gt;</code></td>
</tr>
<tr>
<td><code>[</code></td>
<td><code>??(</code></td>
</tr>
<tr>
<td><code>]</code></td>
<td><code>??)</code></td>
</tr>
<tr>
<td><code>#</code></td>
<td><code>??=</code></td>
</tr>
<tr>
<td><code>\</code></td>
<td><code>??/</code></td>
</tr>
<tr>
<td><code>^</code></td>
<td><code>??'</code></td>
</tr>
<tr>
<td><code>|</code></td>
<td><code>??!</code></td>
</tr>
<tr>
<td><code>~</code></td>
<td><code>??-</code></td>
</tr>
</tbody>
</table>
<p>二字符跟原字符是完全等价的。与其说是二字符被替换成了原字符，不如说是两者是同一符号的不同写法而已：</p>
<pre><code class="language-C">%:include &lt;stdio.h&gt;
int main(void) &lt;%
    int a&lt;:10:&gt;;
    printf(&quot;%:%:&quot;); // 输出 %:%:
    // 二字符只有解读为运算符的时候才有原字符的意义
%&gt;
</code></pre>
<p>而三字符广为人诟病——因为它进行的是替换，而且时间太早了，可能远超你的想象</p>
<pre><code class="language-C">// 为什么下一行代码总是不会被执行??/
...
</code></pre>
<p><code>??/</code>被替换成了<code>\</code>，然后后面的换行符就被抵消了，所以下一行直接被注释了。</p>
<pre><code class="language-C">printf(&quot;发生什么事了??!&quot;);
</code></pre>
<p>输出<code>"发生什么事了|"</code>。你可以在字符串里面使用<code>'\?'</code>来避免解读为三字符。但如果仅改为<code>"\??!"</code>，依然不奏效，仍然会被替换为<code>"\|"</code>。所以你必须写成<code>"?\?!"</code>，打断三字符的构成。你甚至可以认为，它替换的优先级高于一切：</p>
<pre><code class="language-C">??=include &lt;stdio.h&gt; // #include
printf(&quot;??/n&quot;);      // 输出换行符
x ??'= 3;            // x ^= 3;
</code></pre>
<p>相信你看到三字符满脑子肯定都是<code>??!</code>。实际上，三字符早已过时，还问题重重。C++17 已经正义删除了这个特性。某些编译器，例如 gcc，在默认情况下也不会允许三字符的使用。</p>
<hr />
<p>下表总结了三种转义符号会被翻译的情形。</p>
<table>
<thead>
<tr>
<th></th>
<th>双字符</th>
<th>转义序列</th>
<th>三字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>源代码</td>
<td>转义</td>
<td>仅<code>\u</code>和<code>\U</code></td>
<td>转义且优先</td>
</tr>
<tr>
<td>字符串</td>
<td>不转义</td>
<td>转义</td>
<td>转义且优先</td>
</tr>
<tr>
<td>注释</td>
<td>不转义</td>
<td>不转义</td>
<td>转义且优先</td>
</tr>
</tbody>
</table>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="token.html" class="btn btn-neutral float-left" title="符号"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="preprocessor.html" class="btn btn-neutral float-right" title="预处理器">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/Yaossg/doc" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="token.html" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="preprocessor.html" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
