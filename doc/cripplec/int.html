<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Yaossg" /><link rel="canonical" href="https://yaossg.com/doc/cripplec/int.html" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>整数 - Yaossg's Doc</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u6574\u6570";
        var mkdocs_page_input_path = "cripplec/int.md";
        var mkdocs_page_url = "/doc/cripplec/int.html";
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../index.html" class="icon icon-home"> Yaossg's Doc
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../index.html">Yaossg's Doc</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Cripple C</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="index.html">Cripple C</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="concept.html">基本概念</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="token.html">符号</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="text.html">文本</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="preprocessor.html">预处理器</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="op-1.html">运算符（上）</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="op-2.html">运算符（下）</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="int.html">整数</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#_2">整数类型</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_3">可移植性缺陷</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_4">整数的宽度</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_5">整数的符号性</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_6">有符号数的实现</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_7">除法与右移</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_8">求余还是求模</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_9">定长整型</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_10">位段</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_11">底层类型</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_12">位段的布局</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_13">八进制常量</a>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="conv.html">隐式转换</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="cdecl.html">cdecl</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">字符集与编码</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../ce/overview.html">概述</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Yaossg's Doc</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html" class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>Cripple C &raquo;</li>
      <li>整数</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/Yaossg/doc/edit/master/docs/cripplec/int.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="_1">整数</h1>
<p><em>程序员为什么没有办法分清万圣节和圣诞节？</em></p>
<h2 id="_2">整数类型</h2>
<p>毫无疑问，整数是编程中使用最多的数据类型。C 语言提供了丰富的整数类型，如下表所示：</p>
<table>
<thead>
<tr>
<th>有符号</th>
<th>无符号</th>
<th>宽度（比特）</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>signed char</code></td>
<td><code>unsigned char</code></td>
<td>8</td>
</tr>
<tr>
<td><code>signed short int</code><br/><code>signed short</code><br/><code>short int</code><br/><code>short</code></td>
<td><code>unsigned short int</code><br/><code>unsigned short</code></td>
<td>至少 16</td>
</tr>
<tr>
<td><code>signed int</code><br/><code>signed</code><br/><code>int</code></td>
<td><code>unsigned int</code><br/><code>unsigned</code></td>
<td>至少 16</td>
</tr>
<tr>
<td><code>signed long int</code><br/><code>signed long</code><br/><code>long int</code><br/><code>long</code></td>
<td><code>unsigned long int</code><br/><code>unsigned long</code></td>
<td>至少 32</td>
</tr>
<tr>
<td><code>signed long long int</code><br/><code>signed long long</code><br/><code>long long int</code><br/><code>long long</code></td>
<td><code>unsigned long long int</code><br/><code>unsigned long long</code></td>
<td>至少 64</td>
</tr>
</tbody>
</table>
<p>同一个单元格中的类型是等价的。任何一个由多个关键字组成的类型，你都可以任意打乱关键字的顺序。</p>
<p>下面围绕着我们用的最多的整型，来看看我们会遇到哪些问题。</p>
<h2 id="_3">可移植性缺陷</h2>
<h3 id="_4">整数的宽度</h3>
<p>所谓整数的宽度（width）是指整数的位数。</p>
<p>上表中的“至少”二字意味着我们不能保证整数的宽度，进而造成一些意外的溢出。不过 C 语言至少保证<code>1 == sizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long) &lt;= sizeof(long long)</code>。</p>
<p>C 的宏（C++ 的关键字）<code>wchar_t</code>，作为平台相关的宽字符，在 Windows 下是两字节，而在 *nix 下是四字节。因此依赖于<code>wchar_t</code>宽度的也是不可靠的。</p>
<h3 id="_5">整数的符号性</h3>
<p>所谓整数的符号性（signedness）是指整数是否可以表示负数。绝大多数整数类型默认都是<code>signed</code>的。</p>
<p><code>char</code>等价于<code>signed char</code>和<code>unsigned char</code>中的任意一个，是由编译器决定的，而不是默认<code>signed</code>。因此依赖于<code>char</code>的符号性是不可靠的。但是<code>char</code>有一样是非常可靠的，那就是它的宽度——<code>sizeof(char) == 1</code>恒成立！</p>
<p>C99 还引入了<code>_Bool</code>类型。它只有一个位，表示 0 或 1，即假或真。此外，<code>_Bool</code>是无符号的。如果只有一位还是有符号的会怎么样？那就只能表示 0 或 -1 咯。（想一想，为什么？）</p>
<h3 id="_6">有符号数的实现</h3>
<p>对于现代人来说，使用补码（two's complement）表示有符号数简直是天经地义。然而，在 C23 和 C++20 之前，标准并没有废除对其它表示方法的支持。也就是是说，不排除遇到极为罕见的反码（one's complement，即取相反数时只取反，不加一）乃至是原码（sign-and-magnitude，即相反数即为原数字仅最高位反转后的数字）的可能性。这就意味着，一切涉及到有符号数实现的操作，例如在有符号数整数溢出时的行为，都是实现定义的！</p>
<p>当然这似乎太钻牛角尖了，几乎所有 C 编译器和所有的 C++ 编译器都使用补码表示有符号数，考虑这个问题多少有点杞人忧天。如果你真的遇上了其它的情况，倒也不能不说是一件幸事。</p>
<h3 id="_7">除法与右移</h3>
<p><a href="op-2.html#位移运算">这里</a>提到左移和乘法转换的时候需要注意优先级问题。其实右移和除法也是，但是还有更多的因素需要考虑。</p>
<pre><code class="language-C">printf(&quot;%d\n&quot;, -1 / 2);
printf(&quot;%d\n&quot;, -1 &gt;&gt; 1);
</code></pre>
<p>C99 要求：商向 0 取整。所以第一行输出 0。</p>
<p>C++20 要求：有符号数右移时，最高位补符号位（即，算术右移，造成的结果是向负无穷取整）。所以第二行输出 -1。</p>
<p>也就是说，在被除数是负数的情况下，除法与右移的舍入方向是不同的。</p>
<p>你可能注意到我在要求前面加的标准了，没错，尽管大多数编译器都遵循这两个惯例，但是在对应的标准之前，它是不被保证的。</p>
<p>另外要注意不要与个别语言的例外行为混淆，如 Python 的<code>-1 // 2</code>结果为<code>-1</code>（Python 中<code>//</code>才是整除）。</p>
<p>而右移的这个问题，我们可以进一步讨论一下。对于有符号数而言，我们一般把最高位补 0 的右移成为逻辑右移，最高位补符号位的右移成为算术右移。C 语言和 C++20 之前都没有对此作明确的规定，也就是说任何一种右移都可能，因此最好不要依赖于这一点。推而广之的，我建议在进行位运算的时候，尽可能的使用无符号整数，来确保运算不会因为其他算术运算对符号位的特殊处理而收到干扰。关于这一点，你会在<a href="conv.html#整型的共同类型">这里</a>中了解更多。</p>
<h3 id="_8">求余还是求模</h3>
<p>根据前面除法的定义，我们已经可以知道，<code>%</code>是求余而不是求模（与之对应的，Python 的<code>%</code>就是求模）。</p>
<p>注意，C 语言的<code>%</code>的操作数只能是整数。如果想用浮点数，可以使用<code>&lt;math.h&gt;</code>提供的<code>fmod</code>（对，虽然是求余，但是名字是<code>fmod</code>，而<code>remainder</code>既不是求余也不是求模）。</p>
<p>于是，我们已经合理定义了下面这些运算：</p>
<pre><code class="language-C">3 / 2 == 1 &amp;&amp; 3 % 2 == 1;
-3 / 2 == -1 &amp;&amp; -3 % 2 == -1;
3 / -2 == -1 &amp;&amp; 3 % -2 == 1;
-3 / -2 == 1 &amp;&amp; -3 % -2 == -1;
</code></pre>
<p>它们都符合商乘除数加余数等于被除数（基本的数学要求）和商向零取整（C99 要求）的要求。</p>
<p>你可以思考一下，如果把第二个条件换成别的什么（例如余数大于零），结果及其意义会是什么。</p>
<h2 id="_9">定长整型</h2>
<p>C99 引入了<code>&lt;stdint.h&gt;</code>和<code>&lt;inttypes.h&gt;</code>，来解决整数不定长的问题。但它们也带来了一些问题。</p>
<p><code>&lt;stdint.h&gt;</code>中定义的定长整型基本的格式是：</p>
<pre><code>[u]int[N|_leastN|_fastN|max|ptr]_t
</code></pre>
<p>其中 N 替换为 8, 16, 32, 64 中的一个。</p>
<p>u 的前缀表示无符号数。由于是宏定义，所以下面这种写法大概率也是合法的，但不是良好的形式：</p>
<pre><code class="language-C">unsigned int64_t x; // why not uint64_t?
</code></pre>
<p>可能令你有些意外的是，标准不保证实现给出<code>[u]intN_t</code>的定义。也就是说，从整型的最初的设计，到定长整型的定义，自始至终没有要求编译器真正意义上给出某个定长的整型。这种过分的灵活性是双刃剑。好在大部分的实现还是会给出定长的宏定义。标准同样不保证实现给出<code>[u]intptr_t</code>的定义。</p>
<p><code>[u]intmax_t</code>和<code>[u]intptr_t</code>很好理解，就是最长的整型，和指针对应的整型。<code>least</code>和<code>fast</code>是干嘛的？答案是，<code>least</code>是我们最熟悉的话术：至少 N 比特的整型（这也解释了为什么它可以保证被提供）；而<code>fast</code>则是略令人费解的：最快的 N 比特的整型。例如一种典型的做法是把<code>int_fast16_t</code>定义为<code>int</code>，因为实际上对<code>short</code>的计算都先提升到了<code>int</code>，计算完毕之后又转换回了<code>short</code>（参见<a href="conv.html#整型的提升">这里</a>）。遗憾的是，这样做虽然是有一定道理的，但同样是不能保证的。正因为这里对“最快”的描述非常模糊，我很认同 gcc 对此的理解：<em>Not actually guaranteed to be fastest for all purposes</em>。</p>
<p>假设有这样一段代码：</p>
<pre><code class="language-C">int a;
long long b;
puts(&quot;Please input a 32-bits int and a 64-bits int&quot;);
scanf(&quot;%d%lld&quot;, &amp;a, &amp;b);
printf(&quot;%d, %lld&quot;, a, b);
</code></pre>
<p>你刚刚学习了定长整型，为了增加可移植性，你把代码改成了这样：</p>
<pre><code class="language-C">int32_t a;
int64_t b;
puts(&quot;Please input a 32-bits int and a 64-bits int&quot;);
scanf(&quot;%d%lld&quot;, &amp;a, &amp;b);
printf(&quot;%d, %lld&quot;, a, b);
</code></pre>
<p>一旦用上定长整型，你仿佛就找回一种可移植性上身的感觉，但这恐怕有些得意忘形了。<code>"%d"</code>对应的是<code>int32_t</code>吗？很明显应该是<code>int</code>。<code>"%lld"</code>同理。你这代码不仅没有实现可移植性目标，反而变得不可移植了！（原来那个代码反而是相对而言可移植性更高的版本）</p>
<p>为了解决这个问题，<code>&lt;inttypes.h&gt;</code>中定义了一些宏，帮你写出真正可移植的代码：</p>
<pre><code class="language-C">int32_t a;
int64_t b;
puts(&quot;Please input a 32-bits int and a 64-bits int&quot;);
scanf(&quot;%&quot;SCNd32&quot;%&quot;SCNd64, &amp;a, &amp;b);
printf(&quot;%&quot;PRId32&quot;, %&quot;PRId64, a, b);
</code></pre>
<p>我知道你想说什么，这也太丑了吧。没办法，这就是可移植性的代价。注意这里利用的是字符串字面量在编译时自动连接的特性。</p>
<p>此外，这段代码的可移植性仍然不够高——它不能移植到 C++ 中。字符串末尾的标识符会被 C++ 解读为用户定义字面量，所以最终的可移植版本如下：</p>
<pre><code class="language-C">int32_t a;
int64_t b;
puts(&quot;Please input a 32-bits int and a 64-bits int&quot;);
scanf(&quot;%&quot; SCNd32&quot;%&quot; SCNd64, &amp;a, &amp;b);
printf(&quot;%&quot; PRId32&quot;, %&quot; PRId64, a, b);
</code></pre>
<p>假如有一天，你想把<code>a</code>也改成<code>int64_t</code>。请检查一下，这段代码总共需要修改几处？</p>
<p>（答案：四处，别忘了用来提示输入的字符串！）</p>
<h2 id="_10">位段</h2>
<p>位段（bitfield）可以精确地指定一个整型成员在结构体中占用的比特数。</p>
<h3 id="_11">底层类型</h3>
<p>位段可以是下面四种类型之一</p>
<ul>
<li><code>unsigned</code>，无符号位段，例如<code>unsigned b:3;</code>的范围是<code>0..7</code></li>
<li><code>signed</code>，无符号位段，例如<code>signed b:3;</code>的范围是<code>-4..3</code></li>
<li><code>int</code>，是的，在位段里面，<code>int</code>也变成跟<code>char</code>一样，实现定义有无符号，所以请不要在 C 语言中使用<code>int</code>作为位段的类型。C++ 中规定与<code>signed</code>一致。 </li>
<li><code>_Bool</code>（C99)，无符号位段，只允许<code>_Bool b:1;</code>，与它的隐式转换遵循布尔转换的机制（参见<a href="conv.html#布尔类型">这里</a>）</li>
</ul>
<p>其它整型实现也可以选择支持，位段的位数不能超过底层类型的宽度（C++ 中取消了这个限制，但额外的比特仅作填充用，参见后文）</p>
<pre><code class="language-C">struct S {
 unsigned b : 3;
} s = {7};
++s.b; // 无符号溢出，s.b 变为 0
</code></pre>
<h3 id="_12">位段的布局</h3>
<p>下面假设<code>sizeof(unsigned) == 4</code>。</p>
<p>一个底层整数类型就是位段的分配单位，相邻的段位很可能会被打包到同一个段位之中。如果段位没有名字的话，相应的比特仍会被分配，但不能被使用，成为填充（padding）比特。而宽度为 0 的段位会打断一个分配单位，直接进入下一个分配单位。</p>
<pre><code class="language-C">struct S1 {
    // 通常占用 4 字节：
    // 5  bits: b1
    // 11 bits: 未使用
    // 6  bits: b2
    // 2  bits: b3
    // 8  bits: 未使用
    unsigned b1 : 5;
    unsigned : 11;
    unsigned b2 : 6;
    unsigned b3 : 2;
};
struct S2 {
    // 通常占用 8 字节：
    // 5  bits: b1
    // 27 bits: 未使用
    // 6  bits: b2
    // 15 bits: b3
    // 11 bits: 未使用
    unsigned b1 : 5;
    unsigned : 0; // 开一个新的 unsigned
    unsigned b2 : 6;
    unsigned b3 : 15;
};
</code></pre>
<p>此外，你还需要注意，</p>
<p>对于位段，你不可以：</p>
<ul>
<li>取地址</li>
<li>取大小</li>
<li>取对齐要求</li>
</ul>
<p>对于位段，下面这些行为是实现定义的：</p>
<ul>
<li>
<p>单个位段能否跨越分配单位</p>
</li>
<li>
<p>单个分配单位内的多个位段的顺序</p>
</li>
</ul>
<p>可以发现，位段真正在内存中的布局，是非常依赖于实现的。因此，如果要写可移植性较高的代码，我们应该减少对于位段的内存布局的依赖，而是着眼于利用位段抽象的功能——通过把较少的比特紧凑的安排来减少内存占用——这个功能。</p>
<h2 id="_13">八进制常量</h2>
<p>不要为了对齐在整数开头补 0，比如</p>
<pre><code class="language-C">int a = 134;
int b = 042;
</code></pre>
<p>你可能以为<code>b</code>是<code>42</code>，实际上只有<code>34</code>。</p>
<p>当然，比这更难差觉的情况，出现在连 0 都没有的时候，参见<a href="text.html#数字转义序列">这里</a>。</p>
<p><em>程序员为什么没有办法分清万圣节和圣诞节？因为 Oct 31 = Dec 25 啊。</em></p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="op-2.html" class="btn btn-neutral float-left" title="运算符（下）"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="conv.html" class="btn btn-neutral float-right" title="隐式转换">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/Yaossg/doc" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="op-2.html" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="conv.html" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
