"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[986],{3905:(e,n,a)=>{a.d(n,{Zo:()=>s,kt:()=>u});var r=a(67294);function i(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function t(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,r)}return a}function l(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?t(Object(a),!0).forEach((function(n){i(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):t(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function d(e,n){if(null==e)return{};var a,r,i=function(e,n){if(null==e)return{};var a,r,i={},t=Object.keys(e);for(r=0;r<t.length;r++)a=t[r],n.indexOf(a)>=0||(i[a]=e[a]);return i}(e,n);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);for(r=0;r<t.length;r++)a=t[r],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var p=r.createContext({}),o=function(e){var n=r.useContext(p),a=n;return e&&(a="function"==typeof e?e(n):l(l({},n),e)),a},s=function(e){var n=o(e.components);return r.createElement(p.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var a=e.components,i=e.mdxType,t=e.originalType,p=e.parentName,s=d(e,["components","mdxType","originalType","parentName"]),m=o(a),u=i,f=m["".concat(p,".").concat(u)]||m[u]||c[u]||t;return a?r.createElement(f,l(l({ref:n},s),{},{components:a})):r.createElement(f,l({ref:n},s))}));function u(e,n){var a=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var t=a.length,l=new Array(t);l[0]=m;var d={};for(var p in n)hasOwnProperty.call(n,p)&&(d[p]=n[p]);d.originalType=e,d.mdxType="string"==typeof e?e:i,l[1]=d;for(var o=2;o<t;o++)l[o]=a[o];return r.createElement.apply(null,l)}return r.createElement.apply(null,a)}m.displayName="MDXCreateElement"},24753:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>p,contentTitle:()=>l,default:()=>c,frontMatter:()=>t,metadata:()=>d,toc:()=>o});var r=a(87462),i=(a(67294),a(3905));const t={},l="\ud83d\uddbc\ufe0f [C] \u7985\u4e0e\u8ba1\u7b97\u673a\u7ef4\u4fee\u827a\u672f",d={unversionedId:"cnss/C",id:"cnss/C",title:"\ud83d\uddbc\ufe0f [C] \u7985\u4e0e\u8ba1\u7b97\u673a\u7ef4\u4fee\u827a\u672f",description:"\u9898\u76ee",source:"@site/docs/cnss/C.md",sourceDirName:"cnss",slug:"/cnss/C",permalink:"/site/docs/cnss/C",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"\ud83c\udf10 [B] \u81ea\u4e0a\u800c\u4e0b\u7684\u7f51\u7edc\u63a2\u9669",permalink:"/site/docs/cnss/B"},next:{title:"\ud83d\udd0a [D]\u3010ECHO\u3011Re:Master 15",permalink:"/site/docs/cnss/D"}},p={},o=[{value:"\u9898\u76ee",id:"\u9898\u76ee",level:2},{value:"\ud83d\udcd2 \u5148\u884c\u9898\u76ee",id:"-\u5148\u884c\u9898\u76ee",level:3},{value:"\ud83d\udcd2 \u6b63\u5f0f\u9898\u76ee",id:"-\u6b63\u5f0f\u9898\u76ee",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3",level:2},{value:"\ud83d\udcd2 \u5148\u884c\u9898\u76ee",id:"-\u5148\u884c\u9898\u76ee-1",level:3},{value:"1",id:"1",level:4},{value:"2",id:"2",level:4},{value:"3",id:"3",level:4},{value:"4",id:"4",level:4},{value:"\ud83d\udcd2 \u6b63\u5f0f\u9898\u76ee",id:"-\u6b63\u5f0f\u9898\u76ee-1",level:3}],s={toc:o};function c(e){let{components:n,...a}=e;return(0,i.kt)("wrapper",(0,r.Z)({},s,a,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"\ufe0f-c-\u7985\u4e0e\u8ba1\u7b97\u673a\u7ef4\u4fee\u827a\u672f"},"\ud83d\uddbc\ufe0f ","[C]"," \u7985\u4e0e\u8ba1\u7b97\u673a\u7ef4\u4fee\u827a\u672f"),(0,i.kt)("h2",{id:"\u9898\u76ee"},"\u9898\u76ee"),(0,i.kt)("h3",{id:"-\u5148\u884c\u9898\u76ee"},"\ud83d\udcd2 \u5148\u884c\u9898\u76ee"),(0,i.kt)("p",null,"\u5728\u4f60\u7684 wp \u5f00\u59cb\uff0c\u8bf7\u4f60\u5148\u56de\u7b54\u4ee5\u4e0b\u95ee\u9898\u3002"),(0,i.kt)("p",null,"\u8fd9\u56db\u9053\u95ee\u9898\u7684\u56de\u7b54\u4e0d\u5360\u603b\u5206\uff0c\u4f46\u662f\u7b54\u9519\u4e00\u9053\u4ee5\u4e0a\u7684\u9898\u76ee\u5c06\u4f1a\u76f4\u63a5\u6253\u56de wp\u3002\u8bf7\u8ba4\u771f\u4f5c\u7b54\u3002"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"\u89c2\u5bdf\u4ee5\u4e0b\u4ee3\u7801\u5728 Racket v8.3 \u4e2d\u7684\u8fd0\u884c\u7ed3\u679c\uff1a"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-scheme"},"> cons\n#<procedure:cons>\n> if\n; stdin:1:0: if: bad syntax\n;   in: if\n; [,bt for context]\n")),(0,i.kt)("p",{parentName:"li"},"\u4ece\u4e0a\u8ff0\u4ee3\u7801\u53ef\u4ee5\u770b\u51fa\uff0c",(0,i.kt)("inlineCode",{parentName:"p"},"cons")," \u662f\u4e00\u4e2a\u5185\u7f6e\u8fc7\u7a0b\uff0c\u800c ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," ",(0,i.kt)("strong",{parentName:"p"},"\u4e0d\u662f"),"\u5185\u7f6e\u8fc7\u7a0b\u3002\u8bd5\u5206\u6790\u5728 Scheme \u4e2d\u4e3a\u4ec0\u4e48",(0,i.kt)("strong",{parentName:"p"},"\u4e0d\u5e94\u8be5"),"\u5c06 ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," \u5b9a\u4e49\u4e3a\u4e00\u4e2a\u8fc7\u7a0b\u3002\u4f60\u9700\u8981\u5728\u5206\u6790\u4e2d\u5b89\u63d2\u9002\u5f53\u7684\u4e3e\u4f8b\u8bba\u8bc1\u3002"),(0,i.kt)("p",{parentName:"li"},"\u987a\u4fbf\u8bf4\u8bf4\u4ec0\u4e48\u201c\u8fc7\u7a0b\u201d\u4e0d\u80fd\u5185\u7f6e\uff0c\u4ee5\u53ca\u4e3a\u4ec0\u4e48\u3002")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"\u89c2\u5bdf\u4ee5\u4e0b\u4ee3\u7801\uff1a"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-scheme"},"(define (square-list items)\n    (define (iter things answer)\n    (if (null? things)\n        answer\n        (iter (cdr things)\n            (cons (square (car things)) answer))))\n    (iter items '()))\n")),(0,i.kt)("p",{parentName:"li"},"\u5728\u672c\u4f8b\u4e2d\uff0c\u51fd\u6570 ",(0,i.kt)("inlineCode",{parentName:"p"},"(square-list x)")," \u5e94\u4e0e ",(0,i.kt)("inlineCode",{parentName:"p"},"(map (lambda (x) (* x x)) x)")," \u5177\u6709\u4e00\u6837\u7684\u6548\u679c\uff0c\u5b9e\u9645\u4e0a\uff0c",(0,i.kt)("inlineCode",{parentName:"p"},"square-list")," \u8fd4\u56de\u7684\u7ed3\u679c\u521a\u597d\u662f\u9884\u671f\u7ed3\u679c\u7684 ",(0,i.kt)("inlineCode",{parentName:"p"},"reverse"),"\u3002\u5373\u4fbf\u66f4\u6539 ",(0,i.kt)("inlineCode",{parentName:"p"},"cons")," \u7684\u4e24\u53c2\u6570\u987a\u5e8f\uff0c\u4e5f\u4e0d\u80fd\u5f97\u5230\u9884\u671f\u7ed3\u679c\u3002\u8bd5\u5206\u6790\uff0c\u6709\u6ca1\u6709\u529e\u6cd5\u4fee\u6539\u4e0a\u8ff0\u4ee3\u7801\uff0c\u5728\u4fdd\u6301\u5176\u4e3a",(0,i.kt)("strong",{parentName:"p"},"\u8fed\u4ee3\u8ba1\u7b97\u8fc7\u7a0b"),"\u7684\u540c\u65f6",(0,i.kt)("strong",{parentName:"p"},"\u5728\u76f8\u540c\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e0b"),"\u5f97\u5230\u9884\u671f\u7b54\u6848\uff1f\u82e5\u80fd\uff0c\u8bf7\u9644\u4e0a\u4ee3\u7801\u4e0e\u8bf4\u660e\uff1b\u82e5\u4e0d\u80fd\uff0c\u8bf7\u8bf4\u660e\u7406\u7531\u3002")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"\u8bf7\u4f60\u5229\u7528\u5e8f\u5bf9\uff0c\u5199\u4e00\u4e2a\u524d\u7aef\u63d2\u5165\u5220\u9664\u548c\u540e\u7aef\u63d2\u5165\u5220\u9664\u65f6\u95f4\u590d\u6742\u5ea6\u5747\u4e3a \\Theta(1)\u0398(1) \u7684\u53cc\u7aef\u961f\u5217\u3002\u5982\u679c\u4e0d\u80fd\u76f4\u63a5\u8f93\u51fa\u7684\u8bdd\uff0c\u8bf7\u81ea\u884c\u5b9a\u4e49\u7528\u4e8e\u8f93\u51fa\u7684\u51fd\u6570\u3002")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"\u8bf7\u4f60\u5728\u4e0d\u4f7f\u7528 ",(0,i.kt)("inlineCode",{parentName:"p"},"define"),"\u3001",(0,i.kt)("inlineCode",{parentName:"p"},"let")," \u7b49\u5b9a\u4e49\u3001\u8d4b\u503c\u8bed\u53e5\u7684\u524d\u63d0\u4e0b\uff0c\u5b9e\u73b0\u4e00\u4e2a\u9012\u5f52\u6c42\u6a21 998244353998244353 \u610f\u4e49\u4e0b\u5feb\u901f\u5e42\u7684\u7a0b\u5e8f\u3002"))),(0,i.kt)("hr",null),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"amb \u6c42\u503c\u5668\u662f\u4e00\u79cd\u7528\u4e8e\u89e3\u51b3\u975e\u786e\u5b9a\u6027\u8ba1\u7b97\u95ee\u9898\u7684\u6c42\u503c\u5668\u3002"),(0,i.kt)("pre",{parentName:"blockquote"},(0,i.kt)("code",{parentName:"pre",className:"language-scheme"},"(let ((a (amb 1 2)) \n      (b (amb 1 2))) \n  (require (< a b)) \n  (list a b)) ; (1 2) \n")),(0,i.kt)("p",{parentName:"blockquote"},"\u8fd9\u91cc\uff0c",(0,i.kt)("inlineCode",{parentName:"p"},"(amb args...)")," \u8868\u793a\u7684\u662f\u8fd9\u4e2a\u53d8\u91cf\u6709 ",(0,i.kt)("inlineCode",{parentName:"p"},"args...")," \u8fd9\u4e48\u591a\u79cd\u53d6\u503c\uff0c",(0,i.kt)("inlineCode",{parentName:"p"},"(require fun)")," \u8868\u793a\u7684\u662f\u8981\u6c42 ",(0,i.kt)("inlineCode",{parentName:"p"},"fun")," \u5fc5\u987b\u6210\u7acb\u3002\u968f\u7740 ",(0,i.kt)("inlineCode",{parentName:"p"},"require")," \u8d8a\u6765\u8d8a\u591a\uff0c\u6bcf\u4e2a\u53d8\u91cf\u7684\u53d6\u503c\u53ef\u80fd\u4f1a\u8d8a\u6765\u8d8a\u5c11\uff0c\u6700\u7ec8\u6536\u675f\u4e8e\u82e5\u5e72\u4e2a\u89e3\u4e2d\u3002\n",(0,i.kt)("inlineCode",{parentName:"p"},"amb")," \u6c42\u503c\u5668\u662f\u53ef\u4ee5\u6c42\u591a\u89e3\u95ee\u9898\u7684\uff0c\u4e5f\u6709\u904d\u5386\u65b9\u6cd5\uff0c\u4f8b\u5982\uff1a"),(0,i.kt)("pre",{parentName:"blockquote"},(0,i.kt)("code",{parentName:"pre",className:"language-scheme"},"(amb-possibility-list (+ (amb 1 2) (amb 3 4))) ; (4 5 5 6)\n")),(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("inlineCode",{parentName:"p"},"ramb")," \u662f ",(0,i.kt)("inlineCode",{parentName:"p"},"amb"),"\u6c42\u503c\u7684\u968f\u673a\u7248\u672c\u3002\u76f8\u6bd4\u4e8e ",(0,i.kt)("inlineCode",{parentName:"p"},"amb"),"\uff0c",(0,i.kt)("inlineCode",{parentName:"p"},"ramb")," \u968f\u673a\u9009\u62e9\u4e00\u4e2a\u5206\u652f\u6267\u884c\u3002")),(0,i.kt)("h3",{id:"-\u6b63\u5f0f\u9898\u76ee"},"\ud83d\udcd2 \u6b63\u5f0f\u9898\u76ee"),(0,i.kt)("p",null,"XuKaFy \u60f3\u8981\u5229\u7528 ",(0,i.kt)("inlineCode",{parentName:"p"},"amb")," \u6c42\u503c\u5668\u6c42\u89e3\u516b\u7687\u540e\u95ee\u9898\uff0c\u4f60\u80fd\u5e2e\u5e2e\u4ed6\u5417\uff1f"),(0,i.kt)("p",null,"\u8bf7\u7528 Lisp \u7684\u67d0\u79cd\u65b9\u8a00\u5b8c\u6210\u672c\u9898\u3002\u5728\u672c\u9898\u4e2d\uff0c\u4f60\u9700\u8981\u5b9e\u73b0 ",(0,i.kt)("inlineCode",{parentName:"p"},"amb"),"\u3001",(0,i.kt)("inlineCode",{parentName:"p"},"ramb"),"\u3001",(0,i.kt)("inlineCode",{parentName:"p"},"require")," \u548c ",(0,i.kt)("inlineCode",{parentName:"p"},"amb-possibility-list")," \u56db\u4e2a\u51fd\u6570\uff0c\u5e76\u4e14\u5229\u7528\u8fd9\u4e2a ",(0,i.kt)("inlineCode",{parentName:"p"},"amb")," \u6c42\u503c\u5668\u6c42\u89e3\u516b\u7687\u540e\u95ee\u9898\u3002\u6ce8\u610f\uff0c\u4f60\u63d0\u4ea4\u7684\u4ee3\u7801\u8981\u80fd\u591f\u5355\u72ec\u8fd0\u884c\uff0c\u4e0d\u80fd\u53ea\u5199\u4e00\u90e8\u5206\u3002"),(0,i.kt)("h2",{id:"\u9898\u89e3"},"\u9898\u89e3"),(0,i.kt)("h3",{id:"-\u5148\u884c\u9898\u76ee-1"},"\ud83d\udcd2 \u5148\u884c\u9898\u76ee"),(0,i.kt)("h4",{id:"1"},"1"),(0,i.kt)("p",null,"\u56e0\u4e3a Scheme \u5bf9\u8fc7\u7a0b\u7684\u6240\u6709\u53c2\u6570\u90fd\u4f1a\u6c42\u503c\uff0c\u4f46\u662f if \u53ea\u4f1a\u5bf9\u5176\u4e2d\u4e00\u4e2a\u5206\u652f\u6c42\u503c\u3002\u8fd9\u53ef\u4ee5\u770b\u505a\u4e00\u79cd\u5e7f\u4e49\u7684\u77ed\u8def\u6c42\u503c\u3002"),(0,i.kt)("p",null,"\u4e5f\u5c31\u662f\u8bf4\uff0c\u5f71\u54cd\u6c42\u503c\u4e0e\u5426\u3001\u6c42\u503c\u987a\u5e8f\u7684\u8fc7\u7a0b\u4e0d\u80fd\u5185\u7f6e\u3002"),(0,i.kt)("h4",{id:"2"},"2"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scheme"},"#lang racket\n\n(define (entry node) (mcar node))\n(define (prev node) (mcar (mcdr node)))\n(define (next node) (mcdr (mcdr node)))\n(define (set-prev! node new) (set-mcar! (mcdr node) new))\n(define (set-next! node new) (set-mcdr! (mcdr node) new))\n(define (make-node entry prev next) (mcons entry (mcons prev next)))\n(define (make-deque entry) (let ((node (make-node entry '() '()))) (mcons node node)))\n(define (push-front deque entry)\n  (let* (\n        (first-node (mcar deque))\n        (new-node (make-node entry '() first-node))\n        )\n    (set-prev! first-node new-node)\n    (set-mcar! deque new-node)\n    )\n  )\n(define (pop-back deque)\n  (let* (\n        (last-node (mcdr deque))\n        (new-node (prev last-node))\n        )\n    (set-next! new-node '())\n    (set-mcdr! deque new-node)\n    )\n  )\n(define (square x) (* x x))\n(define (square-list items)\n  (define d (make-deque 0))\n  (define (iter things)\n    (unless (null? things)\n      (begin (push-front d (square (car things))) (iter (cdr things)))))\n  (iter items)\n  (pop-back d)\n  (define (deque->list d ans)\n    (if (null? d) ans (deque->list (next d) (cons (entry d) ans)))\n    )\n  (deque->list (mcar d) '())\n  )\n")),(0,i.kt)("h4",{id:"3"},"3"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scheme"},"#lang racket\n\n(define (entry node) (mcar node))\n(define (prev node) (mcar (mcdr node)))\n(define (next node) (mcdr (mcdr node)))\n(define (set-prev! node new) (set-mcar! (mcdr node) new))\n(define (set-next! node new) (set-mcdr! (mcdr node) new))\n(define (make-node entry prev next) (mcons entry (mcons prev next)))\n(define (make-deque entry) (let ((node (make-node entry '() '()))) (mcons node node)))\n(define (print-deque deque)\n  (define (print-node node)\n    (unless (null? node) (begin (printf \" ~a\" (entry node)) (print-node (next node))))\n    )\n  (display \"(deque\")\n  (print-node (mcar deque))\n  (display \")\\n\")\n  )\n(define (push-back deque entry)\n  (let* (\n        (last-node (mcdr deque))\n        (new-node (make-node entry last-node '()))\n        )\n    (set-next! last-node new-node)\n    (set-mcdr! deque new-node)\n    )\n  )\n(define (push-front deque entry)\n  (let* (\n        (first-node (mcar deque))\n        (new-node (make-node entry '() first-node))\n        )\n    (set-prev! first-node new-node)\n    (set-mcar! deque new-node)\n    )\n  )\n(define (pop-back deque)\n  (let* (\n        (last-node (mcdr deque))\n        (new-node (prev last-node))\n        )\n    (set-next! new-node '())\n    (set-mcdr! deque new-node)\n    )\n  )\n(define (pop-front deque)\n  (let* (\n        (first-node (mcar deque))\n        (new-node (next first-node))\n        )\n    (set-prev! new-node '())\n    (set-mcar! deque new-node)\n    )\n  )\n(define d (make-deque 1))\n(print-deque d)\n(push-front d 2)\n(print-deque d)\n(push-back d 3)\n(print-deque d)\n(push-front d 4)\n(print-deque d)\n(pop-back d)\n(print-deque d)\n(pop-front d)\n(print-deque d)\n")),(0,i.kt)("h4",{id:"4"},"4"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scheme"},"#lang racket\n\n(\n (lambda (f a n) (f f a n))\n (lambda (f a n)\n  (remainder (cond ((= n 0) 1)\n        ((= n 1) a)\n        ((= (remainder n 2) 1) (* a (f f a (- n 1))))\n        (else (f f (* a a) (/ n 2)))\n        ) 998244353)\n  )\n2 100\n)\n")),(0,i.kt)("h3",{id:"-\u6b63\u5f0f\u9898\u76ee-1"},"\ud83d\udcd2 \u6b63\u5f0f\u9898\u76ee"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scheme"},"#lang sicp\n\n; algorithm\n\n(define (shuffle x)\n  (do ((v (list->vector x)) (n (length x) (- n 1)))\n      ((zero? n) (vector->list v))\n    (let* ((r (random n)) (t (vector-ref v r)))\n      (vector-set! v r (vector-ref v (- n 1)))\n      (vector-set! v (- n 1) t))))\n\n; infrastructure\n\n(define apply-in-underlying-scheme apply)\n\n(define (tagged-list? exp tag)\n  (and (pair? exp) (eq? (car exp) tag)))\n\n(define (self-evaluating? exp)\n  (or (number? exp) (string? exp)))\n\n(define (variable? exp)\n  (symbol? exp))\n\n(define (quoted? exp)\n  (tagged-list? exp 'quote))\n\n(define (text-of-quotation exp)\n  (cadr exp))\n\n(define (assignment? exp)\n  (tagged-list? exp 'set!))\n\n(define (assignment-variable)\n  (cadr exp))\n\n(define (assignment-value)\n  (caddr exp))\n\n(define (definition? exp)\n  (tagged-list? exp 'define))\n\n(define (definition-variable exp)\n  (if (symbol? (cadr exp))\n      (cadr exp)\n      (caadr exp)))\n\n(define (definition-value exp)\n  (if (symbol? (cadr exp))\n      (caddr exp)\n      (make-lambda (cdadr exp)\n                   (cddr exp))))\n\n(define (lambda? exp)\n  (tagged-list? exp 'lambda))\n\n(define (lambda-parameters exp)\n  (cadr exp))\n\n(define (lambda-body exp)\n  (cddr exp))\n\n(define (make-lambda parameters body)\n  (cons 'lambda (cons parameters body)))\n\n(define (if? exp)\n  (tagged-list? exp 'if))\n\n(define (if-cond exp)\n  (cadr exp))\n\n(define (if-then exp)\n  (caddr exp))\n\n(define (if-else exp)\n  (cadddr exp))\n\n(define (make-if cond then else)\n  (list 'if cond then else))\n\n(define (begin? exp)\n  (tagged-list? exp 'begin))\n\n(define (begin-actions exp)\n  (cdr exp))\n\n(define (application? exp)\n  (pair? exp))\n\n(define (operator exp)\n  (car exp))\n\n(define (operands exp)\n  (cdr exp))\n\n(define (true? exp)\n  (not (eq? exp #f)))\n\n(define (make-procedure parameters body env)\n  (list 'procedure parameters body env))\n\n(define (compound-procedure? p)\n  (tagged-list? p 'procedure))\n\n(define (procedure-parameters p)\n  (cadr p))\n\n(define (procedure-body p)\n  (caddr p))\n\n(define (procedure-environment p)\n  (cadddr p))\n\n; syntactic sugar: let\n\n(define (let? exp)\n  (tagged-list? exp 'let))\n\n(define (let-pairs exp)\n  (cadr exp))\n\n(define (let-variables exp)\n  (map car (let-pairs exp)))\n\n(define (let-exps exp)\n  (map cadr (let-pairs exp)))\n\n(define (let-body exp)\n  (cddr exp))\n\n(define (let->combination exp)\n  (cons (make-lambda (let-variables exp) (let-body exp)) (let-exps exp)))\n\n; amb\n\n(define (amb? exp)\n  (tagged-list? exp 'amb))\n\n(define (ramb? exp)\n  (tagged-list? exp 'ramb))\n\n(define (amb-choices exp)\n  (cdr exp))\n\n; analyze\n\n(define (analyze-self-evaluating exp)\n  (lambda (env succeed fail)\n    (succeed exp fail)))\n\n(define (analyze-quoted exp)\n  (let ((qval (text-of-quotation exp)))\n    (lambda (env succeed fail)\n      (succeed qval fail))))\n\n(define (analyze-variable exp)\n  (lambda (env succeed fail)\n    (succeed (lookup-variable-value exp env) fail)))\n\n(define (analyze-assignment exp)\n  (let ((var (assignment-variable exp))\n        (vproc (analyze (assignment-value exp))))\n    (lambda (env succeed fail)\n      (vproc env\n             (lambda (val fail)\n               (let ((old-value\n                      (lookup-variable-value var env)))\n                 (set-variable-value! var val env)\n                 (succeed 'ok\n                          ; backtracking point\n                          (lambda ()\n                            ; recover previous state\n                            (set-variable-value! var old-value env)\n                            ; recurse previous fail\n                            (fail)))))\n             fail))))\n\n(define (analyze-definition exp)\n  (let ((var (definition-variable exp))\n        (vproc (analyze (definition-value exp))))\n    (lambda (env succeed fail)\n      (vproc env\n             (lambda (val fail)\n               (define-variable! var val env)\n               (succeed 'ok fail))\n             fail))))\n\n(define (analyze-if exp)\n  (let ((cproc (analyze (if-cond exp)))\n        (tproc (analyze (if-then exp)))\n        (eproc (analyze (if-else exp))))\n    (lambda (env succeed fail)\n      (cproc env\n             (lambda (cond-value fail)\n               (if (true? cond-value)\n                   (tproc env succeed fail)\n                   (eproc env succeed fail)))\n             fail))))\n\n(define (analyze-lambda exp)\n  (let ((vars (lambda-parameters exp))\n        (bproc (analyze-sequence (lambda-body exp))))\n    (lambda (env succeed fail)\n      (succeed (make-procedure vars bproc env) fail))))\n\n(define (analyze-sequence exps)\n  (define (sequentially proc1 proc2)\n    (lambda (env succeed fail)\n      (proc1 env\n             (lambda (proc1-value fail)\n               (proc2 env succeed fail))\n             fail)))\n  (define (loop first-proc rest-procs)\n    (if (null? rest-procs)\n        first-proc\n        (loop (sequentially first-proc (car rest-procs))\n              (cdr rest-procs))))\n  (let ((procs (map analyze exps)))\n    (if (null? procs)\n        (display \"Empty sequence\"))\n    (loop (car procs) (cdr procs))))\n\n(define (analyze-application exp)\n  (let ((fproc (analyze (operator exp)))\n        (aprocs (map analyze (operands exp))))\n    (lambda (env succeed fail)\n      (fproc env\n             (lambda (proc fail)\n               (get-args aprocs\n                         env\n                         (lambda (args fail)\n                           (execute-application\n                            proc args succeed fail))\n                         fail))\n             fail))))\n\n(define (get-args aprocs env succeed fail)\n  (if (null? aprocs)\n      (succeed '() fail)\n      ((car aprocs) env\n                    (lambda (arg fail)\n                      (get-args (cdr aprocs)\n                                env\n                                (lambda (args fail)\n                                  (succeed (cons arg args)\n                                           fail))\n                                fail))\n                    fail)))\n\n(define (execute-application proc args succeed fail)\n  (cond ((primitive-procedure? proc)\n         (succeed (apply-primitive-procedure proc args)\n                  fail))\n        ((compound-procedure? proc)\n         ((procedure-body proc)\n          (extend-environment (procedure-parameters proc)\n                              args\n                              (procedure-environment proc))\n          succeed\n          fail))))\n\n\n(define (analyze-amb exp)\n  (let ((cprocs (map analyze (amb-choices exp))))\n    (lambda (env succeed fail)\n      (define (try-next choices)\n        (if (null? choices)\n            (fail)\n            ((car choices) env succeed\n                           (lambda () (try-next (cdr choices))))))\n      (try-next cprocs))))\n\n(define (analyze exp)\n  (cond ((self-evaluating? exp) (analyze-self-evaluating exp))\n        ((variable? exp) (analyze-variable exp))\n        ((quoted? exp) (analyze-quoted exp))\n        ((assignment? exp) (analyze-assignment exp))\n        ((definition? exp) (analyze-definition exp))\n        ((if? exp) (analyze-if exp))\n        ((lambda? exp) (analyze-lambda exp))\n        ((begin? exp) (analyze-sequence (begin-actions exp)))\n        ((let? exp) (analyze-application (let->combination exp)))\n        ((amb? exp) (analyze-amb exp))\n        ((ramb? exp) (analyze-amb (cons 'amb (shuffle (cdr exp)))))\n        ((application? exp) (analyze-application exp))\n        (else (display \"cond is not implemented for I'm lazy lol\" exp))))\n\n(define (ambeval exp env succeed fail)\n  ((analyze exp) env succeed fail))\n\n; runtime\n\n(define (enclosing-environment env)\n  (cdr env))\n\n(define (first-frame env)\n  (car env))\n\n(define the-empty-environment '())\n\n(define (make-frame variables values)\n  (cons variables values))\n\n(define (frame-variables frame)\n  (car frame))\n\n(define (frame-values frame)\n  (cdr frame))\n\n(define (add-binding-to-frame! var val frame)\n  (set-car! frame (cons var (car frame)))\n  (set-cdr! frame (cons val (cdr frame))))\n\n\n(define (extend-environment vars vals base-env)\n  (if (= (length vars) (length vals))\n      (cons (make-frame vars vals) base-env)\n      (display \"Mismatched arguments supplied\" vars vals)))\n\n\n(define (lookup-variable-value var env)\n  (define (env-loop env)\n    (define (scan vars vals)\n      (cond ((null? vars)\n             (env-loop (enclosing-environment env)))\n            ((eq? var (car vars))\n             (car vals))\n            (else (scan (cdr vars) (cdr vals)))))\n    (if (eq? env the-empty-environment)\n        (display \"Unbound variable\" var)\n        (let ((frame (first-frame env)))\n          (scan (frame-variables frame)\n                (frame-values frame)))))\n  (env-loop env))\n\n(define (set-variable-value! var val env)\n  (define (env-loop env)\n    (define (scan vars vals)\n      (cond ((null? vars)\n             (env-loop (enclosing-environment env)))\n            ((eq? var (car vars))\n             (set-car! vals val))\n            (else (scan (cdr vars) (cdr vals)))))\n    (if (eq? env the-empty-environment)\n        (display \"Unbound variable\" var)\n        (let ((frame (first-frame env)))\n          (scan (frame-variables frame)\n                (frame-values frame)))))\n  (env-loop env))\n\n(define (define-variable! var val env)\n  (let ((frame (first-frame env)))\n    (define (scan vars vals)\n      (cond ((null? vars)\n             (add-binding-to-frame! var val frame))\n            ((eq? var (car vars))\n             (set-car! vals val))\n            (else (scan (cdr vars) (cdr vals)))))\n    (scan (frame-variables frame)\n          (frame-values frame))))\n\n\n(define (primitive-procedure? proc)\n  (tagged-list? proc 'primitive))\n\n(define (primitive-implementation proc)\n  (cadr proc))\n\n(define primitive-procedures\n  (list (list 'car car)\n        (list 'cdr cdr)\n        (list 'cons cons)\n        (list 'list list)\n        (list 'null? null?)\n        (list 'not not)\n        (list '+ +)\n        (list '- -)\n        (list '* *)\n        (list '/ /)\n        (list '= =)\n        (list '< <)\n        (list '> >)\n        ))\n\n(define (primitive-procedure-names)\n  (map car primitive-procedures))\n\n(define (primitive-procedure-objects)\n  (map (lambda (proc) (list 'primitive (cadr proc)))\n       primitive-procedures))\n\n\n(define (apply-primitive-procedure proc args)\n  (apply-in-underlying-scheme\n   (primitive-implementation proc) args))\n\n(define (setup-environment)\n  (let ((initial-env\n         (extend-environment (primitive-procedure-names)\n                             (primitive-procedure-objects)\n                             the-empty-environment)))\n    (define-variable! 'true #t initial-env)\n    (define-variable! 'false #f initial-env)\n    initial-env))\n\n(define the-global-environment (setup-environment))\n\n\n; amb-possibility-list can be used outside\n(define (amb-possibility-list exp env)\n  (let ((result '()))\n    (ambeval exp env\n             ; success\n             (lambda (val next-alternative)\n               (set! result (cons val result))\n               (next-alternative))\n             ; failure\n             (lambda () 'ok))\n    (reverse result)))\n\n(amb-possibility-list '(+ (amb 1 2) (amb 3 4)) the-global-environment)\n\n\n\n; require can be used in ambeavl\n(ambeval '(define (require p) (if (not p) (amb) 'ok))\n         the-global-environment\n         (lambda (env fail) 'ok)\n         (lambda () 'ok))\n\n; extension: require-not\n(ambeval '(define (require-not p) (if p (amb) 'ok))\n         the-global-environment\n         (lambda (env fail) 'ok)\n         (lambda () 'ok))\n\n; extension: require-queen\n(ambeval '(define (require-queen A B D) (require-not (= A B)) (require-not (= A (+ B D))) (require-not (= A (- B D))))\n          the-global-environment\n         (lambda (env fail) 'ok)\n         (lambda () 'ok))\n\n; 8-queen\n\n(define result (amb-possibility-list \n'(let ((L1 (amb 1 2 3 4 5 6 7 8)))\n   (let ((L2 (amb 1 2 3 4 5 6 7 8)))\n     (require-queen L1 L2 1)\n     (let ((L3 (amb 1 2 3 4 5 6 7 8)))\n       (require-queen L1 L3 2)\n       (require-queen L2 L3 1)\n       (let ((L4 (amb 1 2 3 4 5 6 7 8)))\n         (require-queen L1 L4 3)\n         (require-queen L2 L4 2)\n         (require-queen L3 L4 1)\n         (let ((L5 (amb 1 2 3 4 5 6 7 8)))\n           (require-queen L1 L5 4)\n           (require-queen L2 L5 3)\n           (require-queen L3 L5 2)\n           (require-queen L4 L5 1)\n           (let ((L6 (amb 1 2 3 4 5 6 7 8)))\n             (require-queen L1 L6 5)\n             (require-queen L2 L6 4)\n             (require-queen L3 L6 3)\n             (require-queen L4 L6 2)\n             (require-queen L5 L6 1)\n             (let ((L7 (amb 1 2 3 4 5 6 7 8)))\n               (require-queen L1 L7 6)\n               (require-queen L2 L7 5)\n               (require-queen L3 L7 4)\n               (require-queen L4 L7 3)\n               (require-queen L5 L7 2)\n               (require-queen L6 L7 1)\n               (let ((L8 (amb 1 2 3 4 5 6 7 8)))\n                 (require-queen L1 L8 7)\n                 (require-queen L2 L8 6)\n                 (require-queen L3 L8 5)\n                 (require-queen L4 L8 4)\n                 (require-queen L5 L8 3)\n                 (require-queen L6 L8 2)\n                 (require-queen L7 L8 1)\n                 (list L1 L2 L3 L4 L5 L6 L7 L8)))))))))\n the-global-environment))\n\nresult\n(length result)\n\n; REPL\n\n(define (repl)\n  (define (internal-loop try-again)\n    (let ((input (read)))\n      (if (eq? input 'try-again)\n          (try-again)\n          (begin\n            (display \"; Starting a new problem\")\n            (newline)\n            (ambeval input the-global-environment\n                     ; success\n                     (lambda (val next-alternative)\n                       (display val)\n                       (newline)\n                       (internal-loop next-alternative))\n                     ; failure\n                     (lambda ()\n                       (display \"; There are no more values of \")\n                       (display input)\n                       (newline)\n                       (repl)))))))\n  (internal-loop\n   (lambda ()\n     (display \"; There is no current problem\")\n     (newline)\n     (repl))))\n\n(repl)\n")))}c.isMDXComponent=!0}}]);