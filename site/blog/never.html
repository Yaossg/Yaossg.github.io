<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.4.0">
<title data-rh="true">never say never? ——简介现代类型系统 | Yaossg&#x27;s Site</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://yaossg.com/site/blog/never"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="never say never? ——简介现代类型系统 | Yaossg&#x27;s Site"><meta data-rh="true" name="description" content="注意：本文之探讨现代类型系统中的一些实践，供大家参考。多有不严谨之处，望学术大佬海涵。"><meta data-rh="true" property="og:description" content="注意：本文之探讨现代类型系统中的一些实践，供大家参考。多有不严谨之处，望学术大佬海涵。"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2024-10-08T09:02:35.000Z"><link data-rh="true" rel="icon" href="/site/img/sausage.png"><link data-rh="true" rel="canonical" href="https://yaossg.com/site/blog/never"><link data-rh="true" rel="alternate" href="https://yaossg.com/site/blog/never" hreflang="en"><link data-rh="true" rel="alternate" href="https://yaossg.com/site/blog/never" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","@id":"https://yaossg.com/site/blog/never","mainEntityOfPage":"https://yaossg.com/site/blog/never","url":"https://yaossg.com/site/blog/never","headline":"never say never? ——简介现代类型系统","name":"never say never? ——简介现代类型系统","description":"注意：本文之探讨现代类型系统中的一些实践，供大家参考。多有不严谨之处，望学术大佬海涵。","datePublished":"2024-10-08T09:02:35.000Z","author":[],"keywords":[],"isPartOf":{"@type":"Blog","@id":"https://yaossg.com/site/blog","name":"Blog"}}</script><link rel="alternate" type="application/rss+xml" href="/site/blog/rss.xml" title="Yaossg&#39;s Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/site/blog/atom.xml" title="Yaossg&#39;s Site Atom Feed">




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous"><link rel="stylesheet" href="/site/assets/css/styles.a9fc0603.css">
<script src="/site/assets/js/runtime~main.97b00ebb.js" defer="defer"></script>
<script src="/site/assets/js/main.20baa963.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/site/"><div class="navbar__logo"><img src="/site/img/sausage-128.png" alt="Yaossg&#x27;s Site" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/site/img/sausage-128.png" alt="Yaossg&#x27;s Site" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Yaossg&#x27;s Site</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/site/blog">Blog</a><a class="navbar__item navbar__link" href="/site/docs">Docs</a><a class="navbar__item navbar__link" href="/site/friends">Friends</a></div><div class="navbar__items navbar__items--right"><a href="https://space.bilibili.com/282144386" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Bilibili<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><a href="https://github.com/Yaossg/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">博客列表</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/site/blog/never">never say never? ——简介现代类型系统</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/site/blog/join">表连接算法概览</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/site/blog/ray-intersect">光线—三角形相交算法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/site/blog/simd">&lt;experimental/simd&gt; 初体验</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/site/blog/statistics">速通统计学</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/site/blog/sso">SSO? SOS!</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/site/blog/analytic-geometry">高中圆锥曲线结论</a></li></ul></nav></aside><main class="col col--7"><article><header><h1 class="title_f1Hy">never say never? ——简介现代类型系统</h1><div class="container_mt6G margin-vert--md"><time datetime="2024-10-08T09:02:35.000Z">October 8, 2024</time> · <!-- -->17 min read</div></header><div id="__blog-post-container" class="markdown"><blockquote>
<p>注意：本文之探讨现代类型系统中的一些实践，供大家参考。多有不严谨之处，望学术大佬海涵。</p>
</blockquote>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="类型与类型系统">类型与类型系统<a class="hash-link" aria-label="Direct link to 类型与类型系统" title="Direct link to 类型与类型系统" href="/site/blog/never#类型与类型系统">​</a></h2>
<p>我们先介绍一下什么是类型。</p>
<p>这里我们简单的把类型（type）定义为值（value）的集合。</p>
<p>例如有两个取值的布尔类型：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">bool := {false, true}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>一些类型的取值范围是有限的（例如大部分的基本类型），一些是无限的（如字符串）</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="字面类型">字面类型<a class="hash-link" aria-label="Direct link to 字面类型" title="Direct link to 字面类型" href="/site/blog/never#字面类型">​</a></h3>
<p>在不引起混淆的情况下，值本身也可以作为一种类型的记号，只包含这个值本身，即</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">false := {false}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">true := {true}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这样的类型成为字面类型（Literal Type）。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="联合类型">联合类型<a class="hash-link" aria-label="Direct link to 联合类型" title="Direct link to 联合类型" href="/site/blog/never#联合类型">​</a></h3>
<p>接着我们引入联合类型（Union Type）或和类型（Sum Type）的概念：</p>
<p><code>A</code> 和 <code>B</code> 的联合类型记作 <code>A | B</code>，该类型的值可以取 <code>A</code> 的值，也可以取 <code>B</code> 的值，即在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∪</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\cup B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.05017em">B</span></span></span></span> 中取值。</p>
<p>那么我们可以把布尔类型定义为：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">bool := false | true</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>例如在 Python 中</p>
<div class="language-python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-python codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">from</span><span class="token plain"> typing </span><span class="token keyword" style="color:#00009f">import</span><span class="token plain"> Literal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Mode </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> Literal</span><span class="token punctuation" style="color:#393A34">[</span><span class="token string" style="color:#e3116c">&#x27;r&#x27;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;rb&#x27;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;w&#x27;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;wb&#x27;</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">TrueType </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> Literal</span><span class="token punctuation" style="color:#393A34">[</span><span class="token boolean" style="color:#36acaa">True</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">def</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">open</span><span class="token punctuation" style="color:#393A34">(</span><span class="token builtin">file</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token builtin">str</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> mode</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> Mode</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">-</span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> TrueType</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">return</span><span class="token plain"> </span><span class="token boolean" style="color:#36acaa">True</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>参数 mode 取某几个固定的字面量取值，而返回值一定是 <code>True</code>，这都可以用字面类型很好的表示。用上面的写法，即</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Mode := &#x27;r&#x27; | &#x27;rb&#x27; | &#x27;w&#x27; | &#x27;wb&#x27;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="交类型">交类型<a class="hash-link" aria-label="Direct link to 交类型" title="Direct link to 交类型" href="/site/blog/never#交类型">​</a></h3>
<p>既然有 Union Type 就有 Intersect Type。</p>
<p><code>A</code> 和 <code>B</code> 的交类型（Intersect Type）记作 <code>A &amp; B</code>，该类型的值必须在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∩</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\cap B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.05017em">B</span></span></span></span> 中取。例如</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ReadMode := &#x27;r&#x27; | &#x27;rb&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BinaryMode := &#x27;rb&#x27; | &#x27;wb&#x27;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>那么这两个类型的交类型就是 <code>&#x27;rb&#x27;</code>。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="积类型">积类型<a class="hash-link" aria-label="Direct link to 积类型" title="Direct link to 积类型" href="/site/blog/never#积类型">​</a></h3>
<p>既然有 Sum Type 就有 Product Type。所谓 Product，指的就是笛卡尔积。</p>
<p><code>A</code> 和 <code>B</code> 的交类型（Product Type）记作 <code>A x B</code>，该类型的值必须在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\times B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.05017em">B</span></span></span></span> 中取。例如</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">A = 1 | 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">B = a | b | c</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>那么</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">A x B = (1, a) | (1, b) | (1, c) | (2, a) | (2, b) | (2, c) </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>可以看出，这其实就是元组（Tuple），因此积类型也可以记作 <code>(A, B)</code></p>
<p>二元组还可以被扩展为 n 元组，这里不再赘述。</p>
<p>一元组的取值与原类型相同，故 <code>(A) = A</code>。</p>
<p>零元组非常特殊，只有 <code>()</code> 一个取值，被称为单位类型 <code>Unit</code>。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="子类型">子类型<a class="hash-link" aria-label="Direct link to 子类型" title="Direct link to 子类型" href="/site/blog/never#子类型">​</a></h2>
<p>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>⊂</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">B \subset A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em"></span><span class="mord mathnormal" style="margin-right:0.05017em">B</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span></span></span></span>，则称 <code>B</code> 是 <code>A</code> 的子类型（Subtyping）。</p>
<p>子类型是一个偏序关系。即满足下面三个性质：</p>
<ul>
<li>自反性：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊂</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">A \subset A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span></span></span></span></li>
<li>反对称性：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊂</mo><mi>B</mi><mo>∧</mo><mi>B</mi><mo>⊂</mo><mi>A</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>A</mi><mo>=</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\subset B \land B \subset A \implies A = B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.05017em">B</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em"></span><span class="mord mathnormal" style="margin-right:0.05017em">B</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.7073em;vertical-align:-0.024em"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.05017em">B</span></span></span></span></li>
<li>传递性：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊂</mo><mi>B</mi><mo>∧</mo><mi>B</mi><mo>⊂</mo><mi>C</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>A</mi><mo>⊂</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A\subset B \land B\subset C \implies A\subset C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.05017em">B</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em"></span><span class="mord mathnormal" style="margin-right:0.05017em">B</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.7073em;vertical-align:-0.024em"></span><span class="mord mathnormal" style="margin-right:0.07153em">C</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.07153em">C</span></span></span></span></li>
</ul>
<p>从数学本质上来说，子类型似乎只是子集在类型系统里的新名字。但由于面向对象编程（OOP）的发扬光大，子类型已经成为了非常重要的一个概念。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="面向对象">面向对象<a class="hash-link" aria-label="Direct link to 面向对象" title="Direct link to 面向对象" href="/site/blog/never#面向对象">​</a></h3>
<p>若一个类型继承自另外一个类型，类图如下所示</p>
<!-- -->
<p>根据 OOP 的规则，所有 B 的对象都是一个（is-a）A 的对象。即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>b</mi><mo>∈</mo><mi>B</mi><mo separator="true">,</mo><mi>b</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\forall b \in B, b \in A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em"></span><span class="mord">∀</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.05017em">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span></span></span></span>，也就是说 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>⊂</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">B \subset A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em"></span><span class="mord mathnormal" style="margin-right:0.05017em">B</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span></span></span></span>。因此我们可以说 <code>B</code> 是 <code>A</code> 的子类型。</p>
<p>一般来说，子类型的对象可以隐式转换为父类型，毕竟子类型的取值范围更小，这样的转换天经地义。这个概念可以推广到一般的类型系统中，如我们上面提到的 <code>bool</code> 类型，类图如下所示</p>
<!-- -->
<p>因此，当一个类的所有子类确定，且本身不会有额外的对象（在面向对象里，就是一个抽象类或是接口），那么它的派生关系实际上可以写作所有子类型的联合类型。</p>
<p>显然，根据定义，任意两个类型 <code>A</code> <code>B</code> 都有公共父类型 <code>A | B</code>，同时有公共子类型 <code>A &amp; B</code>，类图如下所示</p>
<!-- -->
<p><code>A &amp; B</code> 常用于表示同时实现两个接口类型。根据定义，它能作为其中任意一个类型的对象被使用。</p>
<p>如果我们要尝试把所有类型的图画出来，你可能会本能的追问两个问题：这个图的顶端是谁？这个图的底端是谁？</p>
<p>其实很多 OOP 语言都实现成了“单根模型”，即所有的类都有一个共同的父类。如 <code>java.lang.Object</code> <code>kotlin.Any</code> <code>System.Object</code> 等等。基于这样的模型，类图的顶端自然就是这个单根。在之后的叙述中，我们把这个类型记作 <code>any</code>，表示所有类型的联合、所有类型的父类型。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="null"><code>null</code><a class="hash-link" aria-label="Direct link to null" title="Direct link to null" href="/site/blog/never#null">​</a></h3>
<p>现在我们来探究一个问题，空指针 <code>null</code> 是什么类型？</p>
<p>你可能会下意识的认为，既然所有类型都可以赋值为 <code>null</code>，那它理所应当是 <code>any</code> 类型的。这忽略了一个事实：只有子类型才可以直接转换为父类型。<code>any</code> 不是除了本身之外任何类型的父类型，所以 <code>null</code> 若是 <code>any</code> 则几乎不能赋值给任何类型。这显然是矛盾的。</p>
<p>稍加思索你会注意到，由于 <code>null</code> 可以赋值给任何类型，所以它实际上是任何类型的子类。即</p>
<!-- -->
<p>实际上，还有一种非常容易思考的方法得出这个结论：既然 <code>null</code> 可以赋值给任何类型，那么所有类型的交集，自然而然有且仅有这一个 <code>null</code> 的取值。</p>
<p>“一切类型的子类型”，这一点可能相当的反直觉，但却符合逻辑与实践。许多带 <code>null</code> 语言的类型系统就是这样实现的。</p>
<p>根据类图，我们可以把把 <code>any</code> 称为 Top Type，<code>null</code> 称为 Bottom Type。用 <code>null</code> 作为 Bottom Type 并非是唯一的选择，我们在后面还会提到别的考虑。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="函数类型">函数类型<a class="hash-link" aria-label="Direct link to 函数类型" title="Direct link to 函数类型" href="/site/blog/never#函数类型">​</a></h2>
<p>我们先来考虑一种特殊的类型——函数类型。</p>
<p>所谓函数类型，即用于描述接受某些参数 <code>A</code>，返回某些返回值 <code>B</code> 的类型，记作 <code>A -&gt; B</code>。</p>
<p>这里只有一个参数，有多个参数的情况，可以用各个参数类型的笛卡尔积来表示。同理，多个返回值的情况也可以轻松表示。即 <code>(A1, A2, ..., An) -&gt; (B1, B2, ..., Bn)</code>。</p>
<p>那么 <code>void</code> 怎么办？考虑到它什么也没有接受/返回，可以用 <code>()</code> 即 <code>Unit</code> 来表示。这个方案把多个参数和返回值用元组表示的规律相统一，成为了很多现代编程语言的实践。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="函数型变">函数型变<a class="hash-link" aria-label="Direct link to 函数型变" title="Direct link to 函数型变" href="/site/blog/never#函数型变">​</a></h3>
<p>下面我们来讨论函数类型之间的类型关系，尤其是其形变（variance）。假设 <code>B</code> 是 <code>A</code> 的子类型。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="协变">协变<a class="hash-link" aria-label="Direct link to 协变" title="Direct link to 协变" href="/site/blog/never#协变">​</a></h4>
<p>考虑下面两个函数及其类型</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">f: () -&gt; A</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">g: () -&gt; B</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>由于 <code>B</code> 是 <code>A</code> 的子类型，所以 <code>g()</code> 的结果是 <code>B</code> 也是 <code>A</code>。那么我们就能说，<code>g</code> 的类型同时也可以是 <code>() -&gt; A</code>。既然所有 <code>() -&gt; B</code> 都是 <code>() -&gt; A</code>，那么前者就是后者的子类型，即</p>
<!-- -->
<p>这样函数派生关系与类型派生关系方向相同的型变成为协变（covariance）</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="逆变">逆变<a class="hash-link" aria-label="Direct link to 逆变" title="Direct link to 逆变" href="/site/blog/never#逆变">​</a></h4>
<p>考虑下面两个函数和两个对象，及其类型</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">f: A -&gt; ()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">g: B -&gt; ()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">a: A</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">b: B</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>由于 <code>B</code> 是 <code>A</code> 的子类型，所以不仅 <code>f(a)</code> 调用是合法的，而且 <code>f(b)</code> 调用也是合法的。那么我们就能说，<code>f</code> 的类型同时也可以是 <code>B -&gt; ()</code>。既然所有 <code>A -&gt; ()</code> 都是 <code>B -&gt; ()</code>，那么前者就是后者的子类型，即</p>
<!-- -->
<p>这样函数派生关系与类型派生关系方向相反的型变成为逆变（contravariance）</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="不变">不变<a class="hash-link" aria-label="Direct link to 不变" title="Direct link to 不变" href="/site/blog/never#不变">​</a></h4>
<p>考虑下面两个函数及其类型</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">f: A -&gt; A</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">g: B -&gt; B</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>显然对于参数而言，可以构成逆变，对于返回值而言，可以构成协变。但是合在一起，派生关系的方向就相互矛盾了。因此这样的函数类型称为不变（invariance）。而</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">f: A -&gt; B</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">g: B -&gt; A</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>则不同，虽然同时构成协变和逆变，但是两者的派生关系是相互平行的。故最终可以得出 <code>A -&gt; B</code> 是 <code>B -&gt; A</code> 的子类型。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="never"><code>never</code><a class="hash-link" aria-label="Direct link to never" title="Direct link to never" href="/site/blog/never#never">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="永不返回">永不返回<a class="hash-link" aria-label="Direct link to 永不返回" title="Direct link to 永不返回" href="/site/blog/never#永不返回">​</a></h3>
<p>当我们说，一个函数不返回任何东西，和一个函数不返回的时候，实际上含义是不一样的。前者会返回，只是没有返回值，后者则是不会回到调用函数的地方。一个典型的例子便是 C/C++ 的 <code>exit</code> 函数，声明如下所示：</p>
<div class="language-cpp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-cpp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token punctuation" style="color:#393A34">[</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">noreturn</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">exit</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> status</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在这里，<code>[[noreturn]]</code> 用来标注函数永远不会返回。你可能已经发觉，<code>[[noreturn]] void</code> 这两个在一起似乎有些多余。难道不会返回的函数还能声明为非 <code>void</code> 的情况吗？许多现代语言引入了 <code>never</code> 类型（一些语言称为 <code>nothing</code>），专门用于表示这种不会返回的函数类型。例如上面的函数就可以表示为</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">exit: int -&gt; never</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>如果我们想要认为构造出一个返回 <code>never</code> 的函数，最简单的方法莫过于</p>
<ul>
<li>调用其它返回 <code>never</code> 的函数</li>
<li>死循环</li>
<li>抛出异常</li>
</ul>
<p>抛出异常看似会返回到上一层栈帧，但实际上不会返回到函数的调用点，故同样是永不返回。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="分支语句">分支语句<a class="hash-link" aria-label="Direct link to 分支语句" title="Direct link to 分支语句" href="/site/blog/never#分支语句">​</a></h3>
<p>考虑下面的语句：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">a: A</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">b: B</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">value = cond ? a : b;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><code>value</code> 是什么类型？为了保证可以接受两个分支的值，显然应该是 <code>A | B</code>。</p>
<p>假如把代码改为</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">value = cond ? a : throw Exception();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>显然两个分支的类型分别是 <code>A</code> 和 <code>never</code>。由于第二个分支不可能返回，所以 <code>value</code> 的类型必然取一个分支的类型 <code>A</code>。根据前面的公式，即 <code>A | never = A</code>。这个恒等式实际上就说明 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>never</mtext><mo>⊂</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\text{never} \subset A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em"></span><span class="mord text"><span class="mord">never</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span></span></span></span>。</p>
<p>稍加思索你会发现，对于任何类型，这个结果都满足。换句话，任何类型都是 <code>never</code> 的父类型。这也与实践相吻合：既然不会返回，那么实际上可以 <code>never</code> 当做任意类型的值来看待。这或许也说明，前面的 <code>[[noreturn]] void</code> 并列，并非是完全多余的。如果你希望它参与运算，或许换成其它类型也是合理的。</p>
<p>由于 <code>never</code> 实际上不可能有任何的取值，我们可以得出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>never</mtext><mo>=</mo><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">\text{never} = \varnothing</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord text"><span class="mord">never</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6633em;vertical-align:-0.0817em"></span><span class="mord amsrm">∅</span></span></span></span>，这也符合上面的数学逻辑。</p>
<p>很显然，我们得出了一种新的 Bottom Type 的方案，那就是 <code>never</code>。</p>
<!-- -->
<p>现在还有个小问题没有解决：如果一个类型系统里面同时有 <code>never</code> 和 <code>null</code>，怎么会出现两个 Bottom Type 呢？难道它们两个都是所有类型的子类型？</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="never-1"><code>never?</code><a class="hash-link" aria-label="Direct link to never-1" title="Direct link to never-1" href="/site/blog/never#never-1">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="空语义">空语义<a class="hash-link" aria-label="Direct link to 空语义" title="Direct link to 空语义" href="/site/blog/never#空语义">​</a></h3>
<p>要先回答这个问题，我们不妨来看看 <code>null</code> 究竟是什么意思。</p>
<p><code>null</code> 最初用来表示空指针，引申为，一个不存在的对象。由于人们常常忘记检查它的存在，所以带来的问题比较多。现代的编程语言有两个实际上等价的解决方案：<code>Option&lt;T&gt;</code> 和 Nullability。</p>
<p>一种方法，<code>Option&lt;T&gt; = T | ()</code>，即要么有值，要么是 <code>()</code>。这样在使用的时候就必须先排除是 <code>()</code> 的情形。</p>
<p>另一种方法称为 Nullability，即默认普通的类型 <code>T</code> 不能包含 <code>null</code>，只有显式添加一个问号 <code>T?</code> 的时候，才可以是接受 <code>null</code>。显然 <code>T? = T | null</code>，是 <code>T</code> 的父类型，不能直接转换为 <code>T</code>，进而就需要额外的检查才能使用。</p>
<p>前一种方案往往用于没有 <code>null</code> 的情况。而我们如果要讨论 <code>never</code> 与 <code>null</code> 并存，故讨论后一种方案更为合理。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="结论">结论<a class="hash-link" aria-label="Direct link to 结论" title="Direct link to 结论" href="/site/blog/never#结论">​</a></h3>
<p>讲到这里其实答案已经呼之欲出，根据 <code>T? = T | null</code>：</p>
<p>令 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mi mathvariant="normal">∅</mi><mo>=</mo><mtext>never</mtext></mrow><annotation encoding="application/x-tex">T = \varnothing = \text{never}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">T</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6633em;vertical-align:-0.0817em"></span><span class="mord amsrm">∅</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord text"><span class="mord">never</span></span></span></span></span>，那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>never</mtext><mo stretchy="false">?</mo><mo>=</mo><mi mathvariant="normal">∅</mi><mi mathvariant="normal">∣</mi><mtext>null</mtext><mo>=</mo><mtext>null</mtext></mrow><annotation encoding="application/x-tex">\text{never}? = \varnothing | \text{null} = \text{null}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord text"><span class="mord">never</span></span><span class="mclose">?</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord amsrm">∅</span><span class="mord">∣</span><span class="mord text"><span class="mord">null</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord text"><span class="mord">null</span></span></span></span></span>。</p>
<p>也就是说，<code>never? = null</code>。</p>
<p>根据定义，<code>T</code> 是 <code>T?</code> 的子类型，所以最终我们得出了结论：<code>never</code> 才是真正的 Bottom Type。</p>
<p>我们也可以画出一个完整的，带 Nullability 的类图：</p>
<!-- -->
<p>推荐 BGM：<a href="https://www.bilibili.com/video/BV1sP411p7Hm/" target="_blank" rel="noopener noreferrer">Never Enough</a></p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--next" href="/site/blog/join"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">表连接算法概览</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a class="table-of-contents__link toc-highlight" href="/site/blog/never#类型与类型系统">类型与类型系统</a><ul><li><a class="table-of-contents__link toc-highlight" href="/site/blog/never#字面类型">字面类型</a></li><li><a class="table-of-contents__link toc-highlight" href="/site/blog/never#联合类型">联合类型</a></li><li><a class="table-of-contents__link toc-highlight" href="/site/blog/never#交类型">交类型</a></li><li><a class="table-of-contents__link toc-highlight" href="/site/blog/never#积类型">积类型</a></li></ul></li><li><a class="table-of-contents__link toc-highlight" href="/site/blog/never#子类型">子类型</a><ul><li><a class="table-of-contents__link toc-highlight" href="/site/blog/never#面向对象">面向对象</a></li><li><a class="table-of-contents__link toc-highlight" href="/site/blog/never#null"><code>null</code></a></li></ul></li><li><a class="table-of-contents__link toc-highlight" href="/site/blog/never#函数类型">函数类型</a><ul><li><a class="table-of-contents__link toc-highlight" href="/site/blog/never#函数型变">函数型变</a></li></ul></li><li><a class="table-of-contents__link toc-highlight" href="/site/blog/never#never"><code>never</code></a><ul><li><a class="table-of-contents__link toc-highlight" href="/site/blog/never#永不返回">永不返回</a></li><li><a class="table-of-contents__link toc-highlight" href="/site/blog/never#分支语句">分支语句</a></li></ul></li><li><a class="table-of-contents__link toc-highlight" href="/site/blog/never#never-1"><code>never?</code></a><ul><li><a class="table-of-contents__link toc-highlight" href="/site/blog/never#空语义">空语义</a></li><li><a class="table-of-contents__link toc-highlight" href="/site/blog/never#结论">结论</a></li></ul></li></ul></div></div></div></div></div><footer class="footer"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Quick Access</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/Yaossg/site" target="_blank" rel="noopener noreferrer" class="footer__link-item">Site Source Code<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">Related Sites</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://yaossg.com/end-poem/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Online End Poem<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Yaossg's Site</div></div></div></footer></div>
</body>
</html>